/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsonpointer";
exports.ids = ["vendor-chunks/jsonpointer"];
exports.modules = {

/***/ "(rsc)/./node_modules/jsonpointer/jsonpointer.js":
/*!*************************************************!*\
  !*** ./node_modules/jsonpointer/jsonpointer.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var hasExcape = /~/;\nvar escapeMatcher = /~[01]/g;\nfunction escapeReplacer(m) {\n    switch(m){\n        case \"~1\":\n            return \"/\";\n        case \"~0\":\n            return \"~\";\n    }\n    throw new Error(\"Invalid tilde escape: \" + m);\n}\nfunction untilde(str) {\n    if (!hasExcape.test(str)) return str;\n    return str.replace(escapeMatcher, escapeReplacer);\n}\nfunction setter(obj, pointer, value) {\n    var part;\n    var hasNextPart;\n    for(var p = 1, len = pointer.length; p < len;){\n        if (pointer[p] === \"constructor\" || pointer[p] === \"prototype\" || pointer[p] === \"__proto__\") return obj;\n        part = untilde(pointer[p++]);\n        hasNextPart = len > p;\n        if (typeof obj[part] === \"undefined\") {\n            // support setting of /-\n            if (Array.isArray(obj) && part === \"-\") {\n                part = obj.length;\n            }\n            // support nested objects/array when setting values\n            if (hasNextPart) {\n                if (pointer[p] !== \"\" && pointer[p] < Infinity || pointer[p] === \"-\") obj[part] = [];\n                else obj[part] = {};\n            }\n        }\n        if (!hasNextPart) break;\n        obj = obj[part];\n    }\n    var oldValue = obj[part];\n    if (value === undefined) delete obj[part];\n    else obj[part] = value;\n    return oldValue;\n}\nfunction compilePointer(pointer) {\n    if (typeof pointer === \"string\") {\n        pointer = pointer.split(\"/\");\n        if (pointer[0] === \"\") return pointer;\n        throw new Error(\"Invalid JSON pointer.\");\n    } else if (Array.isArray(pointer)) {\n        for (const part of pointer){\n            if (typeof part !== \"string\" && typeof part !== \"number\") {\n                throw new Error(\"Invalid JSON pointer. Must be of type string or number.\");\n            }\n        }\n        return pointer;\n    }\n    throw new Error(\"Invalid JSON pointer.\");\n}\nfunction get(obj, pointer) {\n    if (typeof obj !== \"object\") throw new Error(\"Invalid input object.\");\n    pointer = compilePointer(pointer);\n    var len = pointer.length;\n    if (len === 1) return obj;\n    for(var p = 1; p < len;){\n        obj = obj[untilde(pointer[p++])];\n        if (len === p) return obj;\n        if (typeof obj !== \"object\" || obj === null) return undefined;\n    }\n}\nfunction set(obj, pointer, value) {\n    if (typeof obj !== \"object\") throw new Error(\"Invalid input object.\");\n    pointer = compilePointer(pointer);\n    if (pointer.length === 0) throw new Error(\"Invalid JSON pointer for set.\");\n    return setter(obj, pointer, value);\n}\nfunction compile(pointer) {\n    var compiled = compilePointer(pointer);\n    return {\n        get: function(object) {\n            return get(object, compiled);\n        },\n        set: function(object, value) {\n            return set(object, compiled, value);\n        }\n    };\n}\nexports.get = get;\nexports.set = set;\nexports.compile = compile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNvbnBvaW50ZXIvanNvbnBvaW50ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsWUFBWTtBQUNoQixJQUFJQyxnQkFBZ0I7QUFDcEIsU0FBU0MsZUFBZ0JDLENBQUM7SUFDeEIsT0FBUUE7UUFDTixLQUFLO1lBQU0sT0FBTztRQUNsQixLQUFLO1lBQU0sT0FBTztJQUNwQjtJQUNBLE1BQU0sSUFBSUMsTUFBTSwyQkFBMkJEO0FBQzdDO0FBRUEsU0FBU0UsUUFBU0MsR0FBRztJQUNuQixJQUFJLENBQUNOLFVBQVVPLElBQUksQ0FBQ0QsTUFBTSxPQUFPQTtJQUNqQyxPQUFPQSxJQUFJRSxPQUFPLENBQUNQLGVBQWVDO0FBQ3BDO0FBRUEsU0FBU08sT0FBUUMsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLEtBQUs7SUFDbEMsSUFBSUM7SUFDSixJQUFJQztJQUVKLElBQUssSUFBSUMsSUFBSSxHQUFHQyxNQUFNTCxRQUFRTSxNQUFNLEVBQUVGLElBQUlDLEtBQU07UUFDOUMsSUFBSUwsT0FBTyxDQUFDSSxFQUFFLEtBQUssaUJBQWlCSixPQUFPLENBQUNJLEVBQUUsS0FBSyxlQUFlSixPQUFPLENBQUNJLEVBQUUsS0FBSyxhQUFhLE9BQU9MO1FBRXJHRyxPQUFPUixRQUFRTSxPQUFPLENBQUNJLElBQUk7UUFDM0JELGNBQWNFLE1BQU1EO1FBRXBCLElBQUksT0FBT0wsR0FBRyxDQUFDRyxLQUFLLEtBQUssYUFBYTtZQUNwQyx3QkFBd0I7WUFDeEIsSUFBSUssTUFBTUMsT0FBTyxDQUFDVCxRQUFRRyxTQUFTLEtBQUs7Z0JBQ3RDQSxPQUFPSCxJQUFJTyxNQUFNO1lBQ25CO1lBRUEsbURBQW1EO1lBQ25ELElBQUlILGFBQWE7Z0JBQ2YsSUFBSSxPQUFRLENBQUNDLEVBQUUsS0FBSyxNQUFNSixPQUFPLENBQUNJLEVBQUUsR0FBR0ssWUFBYVQsT0FBTyxDQUFDSSxFQUFFLEtBQUssS0FBS0wsR0FBRyxDQUFDRyxLQUFLLEdBQUcsRUFBRTtxQkFDakZILEdBQUcsQ0FBQ0csS0FBSyxHQUFHLENBQUM7WUFDcEI7UUFDRjtRQUVBLElBQUksQ0FBQ0MsYUFBYTtRQUNsQkosTUFBTUEsR0FBRyxDQUFDRyxLQUFLO0lBQ2pCO0lBRUEsSUFBSVEsV0FBV1gsR0FBRyxDQUFDRyxLQUFLO0lBQ3hCLElBQUlELFVBQVVVLFdBQVcsT0FBT1osR0FBRyxDQUFDRyxLQUFLO1NBQ3BDSCxHQUFHLENBQUNHLEtBQUssR0FBR0Q7SUFDakIsT0FBT1M7QUFDVDtBQUVBLFNBQVNFLGVBQWdCWixPQUFPO0lBQzlCLElBQUksT0FBT0EsWUFBWSxVQUFVO1FBQy9CQSxVQUFVQSxRQUFRYSxLQUFLLENBQUM7UUFDeEIsSUFBSWIsT0FBTyxDQUFDLEVBQUUsS0FBSyxJQUFJLE9BQU9BO1FBQzlCLE1BQU0sSUFBSVAsTUFBTTtJQUNsQixPQUFPLElBQUljLE1BQU1DLE9BQU8sQ0FBQ1IsVUFBVTtRQUNqQyxLQUFLLE1BQU1FLFFBQVFGLFFBQVM7WUFDMUIsSUFBSSxPQUFPRSxTQUFTLFlBQVksT0FBT0EsU0FBUyxVQUFVO2dCQUN4RCxNQUFNLElBQUlULE1BQU07WUFDbEI7UUFDRjtRQUNBLE9BQU9PO0lBQ1Q7SUFFQSxNQUFNLElBQUlQLE1BQU07QUFDbEI7QUFFQSxTQUFTcUIsSUFBS2YsR0FBRyxFQUFFQyxPQUFPO0lBQ3hCLElBQUksT0FBT0QsUUFBUSxVQUFVLE1BQU0sSUFBSU4sTUFBTTtJQUM3Q08sVUFBVVksZUFBZVo7SUFDekIsSUFBSUssTUFBTUwsUUFBUU0sTUFBTTtJQUN4QixJQUFJRCxRQUFRLEdBQUcsT0FBT047SUFFdEIsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlDLEtBQU07UUFDeEJOLE1BQU1BLEdBQUcsQ0FBQ0wsUUFBUU0sT0FBTyxDQUFDSSxJQUFJLEVBQUU7UUFDaEMsSUFBSUMsUUFBUUQsR0FBRyxPQUFPTDtRQUN0QixJQUFJLE9BQU9BLFFBQVEsWUFBWUEsUUFBUSxNQUFNLE9BQU9ZO0lBQ3REO0FBQ0Y7QUFFQSxTQUFTSSxJQUFLaEIsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLEtBQUs7SUFDL0IsSUFBSSxPQUFPRixRQUFRLFVBQVUsTUFBTSxJQUFJTixNQUFNO0lBQzdDTyxVQUFVWSxlQUFlWjtJQUN6QixJQUFJQSxRQUFRTSxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUliLE1BQU07SUFDMUMsT0FBT0ssT0FBT0MsS0FBS0MsU0FBU0M7QUFDOUI7QUFFQSxTQUFTZSxRQUFTaEIsT0FBTztJQUN2QixJQUFJaUIsV0FBV0wsZUFBZVo7SUFDOUIsT0FBTztRQUNMYyxLQUFLLFNBQVVJLE1BQU07WUFDbkIsT0FBT0osSUFBSUksUUFBUUQ7UUFDckI7UUFDQUYsS0FBSyxTQUFVRyxNQUFNLEVBQUVqQixLQUFLO1lBQzFCLE9BQU9jLElBQUlHLFFBQVFELFVBQVVoQjtRQUMvQjtJQUNGO0FBQ0Y7QUFFQWtCLFdBQVcsR0FBR0w7QUFDZEssV0FBVyxHQUFHSjtBQUNkSSxlQUFlLEdBQUdIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmV0dGVyLXRvZG8vLi9ub2RlX21vZHVsZXMvanNvbnBvaW50ZXIvanNvbnBvaW50ZXIuanM/ZTMzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzRXhjYXBlID0gL34vXG52YXIgZXNjYXBlTWF0Y2hlciA9IC9+WzAxXS9nXG5mdW5jdGlvbiBlc2NhcGVSZXBsYWNlciAobSkge1xuICBzd2l0Y2ggKG0pIHtcbiAgICBjYXNlICd+MSc6IHJldHVybiAnLydcbiAgICBjYXNlICd+MCc6IHJldHVybiAnfidcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGlsZGUgZXNjYXBlOiAnICsgbSlcbn1cblxuZnVuY3Rpb24gdW50aWxkZSAoc3RyKSB7XG4gIGlmICghaGFzRXhjYXBlLnRlc3Qoc3RyKSkgcmV0dXJuIHN0clxuICByZXR1cm4gc3RyLnJlcGxhY2UoZXNjYXBlTWF0Y2hlciwgZXNjYXBlUmVwbGFjZXIpXG59XG5cbmZ1bmN0aW9uIHNldHRlciAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICB2YXIgcGFydFxuICB2YXIgaGFzTmV4dFBhcnRcblxuICBmb3IgKHZhciBwID0gMSwgbGVuID0gcG9pbnRlci5sZW5ndGg7IHAgPCBsZW47KSB7XG4gICAgaWYgKHBvaW50ZXJbcF0gPT09ICdjb25zdHJ1Y3RvcicgfHwgcG9pbnRlcltwXSA9PT0gJ3Byb3RvdHlwZScgfHwgcG9pbnRlcltwXSA9PT0gJ19fcHJvdG9fXycpIHJldHVybiBvYmpcblxuICAgIHBhcnQgPSB1bnRpbGRlKHBvaW50ZXJbcCsrXSlcbiAgICBoYXNOZXh0UGFydCA9IGxlbiA+IHBcblxuICAgIGlmICh0eXBlb2Ygb2JqW3BhcnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gc3VwcG9ydCBzZXR0aW5nIG9mIC8tXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmIHBhcnQgPT09ICctJykge1xuICAgICAgICBwYXJ0ID0gb2JqLmxlbmd0aFxuICAgICAgfVxuXG4gICAgICAvLyBzdXBwb3J0IG5lc3RlZCBvYmplY3RzL2FycmF5IHdoZW4gc2V0dGluZyB2YWx1ZXNcbiAgICAgIGlmIChoYXNOZXh0UGFydCkge1xuICAgICAgICBpZiAoKHBvaW50ZXJbcF0gIT09ICcnICYmIHBvaW50ZXJbcF0gPCBJbmZpbml0eSkgfHwgcG9pbnRlcltwXSA9PT0gJy0nKSBvYmpbcGFydF0gPSBbXVxuICAgICAgICBlbHNlIG9ialtwYXJ0XSA9IHt9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNOZXh0UGFydCkgYnJlYWtcbiAgICBvYmogPSBvYmpbcGFydF1cbiAgfVxuXG4gIHZhciBvbGRWYWx1ZSA9IG9ialtwYXJ0XVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIG9ialtwYXJ0XVxuICBlbHNlIG9ialtwYXJ0XSA9IHZhbHVlXG4gIHJldHVybiBvbGRWYWx1ZVxufVxuXG5mdW5jdGlvbiBjb21waWxlUG9pbnRlciAocG9pbnRlcikge1xuICBpZiAodHlwZW9mIHBvaW50ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcG9pbnRlciA9IHBvaW50ZXIuc3BsaXQoJy8nKVxuICAgIGlmIChwb2ludGVyWzBdID09PSAnJykgcmV0dXJuIHBvaW50ZXJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyLicpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwb2ludGVyKSkge1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwb2ludGVyKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwYXJ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyLiBNdXN0IGJlIG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlci4nKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9pbnRlclxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlci4nKVxufVxuXG5mdW5jdGlvbiBnZXQgKG9iaiwgcG9pbnRlcikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBvYmplY3QuJylcbiAgcG9pbnRlciA9IGNvbXBpbGVQb2ludGVyKHBvaW50ZXIpXG4gIHZhciBsZW4gPSBwb2ludGVyLmxlbmd0aFxuICBpZiAobGVuID09PSAxKSByZXR1cm4gb2JqXG5cbiAgZm9yICh2YXIgcCA9IDE7IHAgPCBsZW47KSB7XG4gICAgb2JqID0gb2JqW3VudGlsZGUocG9pbnRlcltwKytdKV1cbiAgICBpZiAobGVuID09PSBwKSByZXR1cm4gb2JqXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBvYmplY3QuJylcbiAgcG9pbnRlciA9IGNvbXBpbGVQb2ludGVyKHBvaW50ZXIpXG4gIGlmIChwb2ludGVyLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlciBmb3Igc2V0LicpXG4gIHJldHVybiBzZXR0ZXIob2JqLCBwb2ludGVyLCB2YWx1ZSlcbn1cblxuZnVuY3Rpb24gY29tcGlsZSAocG9pbnRlcikge1xuICB2YXIgY29tcGlsZWQgPSBjb21waWxlUG9pbnRlcihwb2ludGVyKVxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGdldChvYmplY3QsIGNvbXBpbGVkKVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAob2JqZWN0LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNldChvYmplY3QsIGNvbXBpbGVkLCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5nZXQgPSBnZXRcbmV4cG9ydHMuc2V0ID0gc2V0XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG4iXSwibmFtZXMiOlsiaGFzRXhjYXBlIiwiZXNjYXBlTWF0Y2hlciIsImVzY2FwZVJlcGxhY2VyIiwibSIsIkVycm9yIiwidW50aWxkZSIsInN0ciIsInRlc3QiLCJyZXBsYWNlIiwic2V0dGVyIiwib2JqIiwicG9pbnRlciIsInZhbHVlIiwicGFydCIsImhhc05leHRQYXJ0IiwicCIsImxlbiIsImxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsIkluZmluaXR5Iiwib2xkVmFsdWUiLCJ1bmRlZmluZWQiLCJjb21waWxlUG9pbnRlciIsInNwbGl0IiwiZ2V0Iiwic2V0IiwiY29tcGlsZSIsImNvbXBpbGVkIiwib2JqZWN0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsonpointer/jsonpointer.js\n");

/***/ })

};
;