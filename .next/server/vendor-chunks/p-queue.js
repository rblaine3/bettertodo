"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/p-queue";
exports.ids = ["vendor-chunks/p-queue"];
exports.modules = {

/***/ "(rsc)/./node_modules/p-queue/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/p-queue/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst EventEmitter = __webpack_require__(/*! eventemitter3 */ \"(rsc)/./node_modules/eventemitter3/index.js\");\nconst p_timeout_1 = __webpack_require__(/*! p-timeout */ \"(rsc)/./node_modules/p-timeout/index.js\");\nconst priority_queue_1 = __webpack_require__(/*! ./priority-queue */ \"(rsc)/./node_modules/p-queue/dist/priority-queue.js\");\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst empty = ()=>{};\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/ class PQueue extends EventEmitter {\n    constructor(options){\n        var _a, _b, _c, _d;\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = Object.assign({\n            carryoverConcurrencyCount: false,\n            intervalCap: Infinity,\n            interval: 0,\n            concurrency: Infinity,\n            autoStart: true,\n            queueClass: priority_queue_1.default\n        }, options);\n        if (!(typeof options.intervalCap === \"number\" && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\"}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n        this.emit(\"next\");\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n            this.emit(\"idle\");\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n            } else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(()=>{\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                const job = this._queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit(\"active\");\n                job();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(()=>{\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */ _processQueue() {\n        // eslint-disable-next-line no-empty\n        while(this._tryToStartAnother()){}\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === \"number\" && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */ async add(fn, options = {}) {\n        return new Promise((resolve, reject)=>{\n            const run = async ()=>{\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = this._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? this._timeout : options.timeout, ()=>{\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                } catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n            this.emit(\"add\");\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */ async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_)=>this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */ start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */ pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */ clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */ async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise((resolve)=>{\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = ()=>{\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */ async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise((resolve)=>{\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = ()=>{\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */ get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */ sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */ get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */ get isPaused() {\n        return this._isPaused;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */ set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n}\nexports[\"default\"] = PQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGVBQWVDLG1CQUFPQSxDQUFDLGtFQUFlO0FBQzVDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDBEQUFXO0FBQ3ZDLE1BQU1FLG1CQUFtQkYsbUJBQU9BLENBQUMsNkVBQWtCO0FBQ25ELGdFQUFnRTtBQUNoRSxNQUFNRyxRQUFRLEtBQVE7QUFDdEIsTUFBTUMsZUFBZSxJQUFJSCxZQUFZSSxZQUFZO0FBQ2pEOztBQUVBLEdBQ0EsTUFBTUMsZUFBZVA7SUFDakJRLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUNoQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUdiO1FBQ3JCLElBQUksQ0FBQ2MsWUFBWSxHQUFHZDtRQUNwQix5RUFBeUU7UUFDekVLLFVBQVViLE9BQU91QixNQUFNLENBQUM7WUFBRUMsMkJBQTJCO1lBQU9DLGFBQWFDO1lBQVVDLFVBQVU7WUFBR0MsYUFBYUY7WUFBVUcsV0FBVztZQUFNQyxZQUFZdkIsaUJBQWlCd0IsT0FBTztRQUFDLEdBQUdsQjtRQUNoTCxJQUFJLENBQUUsUUFBT0EsUUFBUVksV0FBVyxLQUFLLFlBQVlaLFFBQVFZLFdBQVcsSUFBSSxJQUFJO1lBQ3hFLE1BQU0sSUFBSU8sVUFBVSxDQUFDLDZEQUE2RCxFQUFFLENBQUNqQixLQUFLLENBQUNELEtBQUtELFFBQVFZLFdBQVcsTUFBTSxRQUFRWCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtQixRQUFRLEVBQUMsTUFBTyxRQUFRbEIsT0FBTyxLQUFLLElBQUlBLEtBQUssR0FB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YSxHQUFHO2dCQUNqQnNFO2dCQUNBZjtZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7O0lBSUEsR0FDQSxNQUFNZ0IsU0FBUztRQUNYLGtFQUFrRTtRQUNsRSxJQUFJLElBQUksQ0FBQ3hFLGFBQWEsS0FBSyxLQUFLLElBQUksQ0FBQ3FCLE1BQU0sQ0FBQ3dCLElBQUksS0FBSyxHQUFHO1lBQ3BEO1FBQ0o7UUFDQSxPQUFPLElBQUlVLFFBQVFDLENBQUFBO1lBQ2YsTUFBTWUsa0JBQWtCLElBQUksQ0FBQ3JFLFlBQVk7WUFDekMsSUFBSSxDQUFDQSxZQUFZLEdBQUc7Z0JBQ2hCcUU7Z0JBQ0FmO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7O0lBRUEsR0FDQSxJQUFJWCxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUN4QixNQUFNLENBQUN3QixJQUFJO0lBQzNCO0lBQ0E7Ozs7SUFJQSxHQUNBNEIsT0FBT2hGLE9BQU8sRUFBRTtRQUNaLCtEQUErRDtRQUMvRCxPQUFPLElBQUksQ0FBQzRCLE1BQU0sQ0FBQ3FELE1BQU0sQ0FBQ2pGLFNBQVNrRixNQUFNO0lBQzdDO0lBQ0E7O0lBRUEsR0FDQSxJQUFJQyxVQUFVO1FBQ1YsT0FBTyxJQUFJLENBQUM1RSxhQUFhO0lBQzdCO0lBQ0E7O0lBRUEsR0FDQSxJQUFJNkUsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDbEQsU0FBUztJQUN6QjtJQUNBLElBQUlILFVBQVU7UUFDVixPQUFPLElBQUksQ0FBQ0QsUUFBUTtJQUN4QjtJQUNBOztJQUVBLEdBQ0EsSUFBSUMsUUFBUXNELFlBQVksRUFBRTtRQUN0QixJQUFJLENBQUN2RCxRQUFRLEdBQUd1RDtJQUNwQjtBQUNKO0FBQ0FoRyxrQkFBZSxHQUFHUyIsInNvdXJjZXMiOlsid2VicGFjazovL2JldHRlci10b2RvLy4vbm9kZV9tb2R1bGVzL3AtcXVldWUvZGlzdC9pbmRleC5qcz83ZGVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5jb25zdCBwX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCJwLXRpbWVvdXRcIik7XG5jb25zdCBwcmlvcml0eV9xdWV1ZV8xID0gcmVxdWlyZShcIi4vcHJpb3JpdHktcXVldWVcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5jb25zdCBlbXB0eSA9ICgpID0+IHsgfTtcbmNvbnN0IHRpbWVvdXRFcnJvciA9IG5ldyBwX3RpbWVvdXRfMS5UaW1lb3V0RXJyb3IoKTtcbi8qKlxuUHJvbWlzZSBxdWV1ZSB3aXRoIGNvbmN1cnJlbmN5IGNvbnRyb2wuXG4qL1xuY2xhc3MgUFF1ZXVlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2ludGVydmFsRW5kID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5ID0gZW1wdHk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVJZGxlID0gZW1wdHk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWFzc2VydGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50OiBmYWxzZSwgaW50ZXJ2YWxDYXA6IEluZmluaXR5LCBpbnRlcnZhbDogMCwgY29uY3VycmVuY3k6IEluZmluaXR5LCBhdXRvU3RhcnQ6IHRydWUsIHF1ZXVlQ2xhc3M6IHByaW9yaXR5X3F1ZXVlXzEuZGVmYXVsdCB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCEodHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWxDYXAgPT09ICdudW1iZXInICYmIG9wdGlvbnMuaW50ZXJ2YWxDYXAgPj0gMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGludGVydmFsQ2FwXFxgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAsIGdvdCBcXGAkeyhfYiA9IChfYSA9IG9wdGlvbnMuaW50ZXJ2YWxDYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJ31cXGAgKCR7dHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWxDYXB9KWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludGVydmFsID09PSB1bmRlZmluZWQgfHwgIShOdW1iZXIuaXNGaW5pdGUob3B0aW9ucy5pbnRlcnZhbCkgJiYgb3B0aW9ucy5pbnRlcnZhbCA+PSAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgaW50ZXJ2YWxcXGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyID49IDAsIGdvdCBcXGAkeyhfZCA9IChfYyA9IG9wdGlvbnMuaW50ZXJ2YWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJ31cXGAgKCR7dHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWx9KWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQgPSBvcHRpb25zLmNhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQ7XG4gICAgICAgIHRoaXMuX2lzSW50ZXJ2YWxJZ25vcmVkID0gb3B0aW9ucy5pbnRlcnZhbENhcCA9PT0gSW5maW5pdHkgfHwgb3B0aW9ucy5pbnRlcnZhbCA9PT0gMDtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxDYXAgPSBvcHRpb25zLmludGVydmFsQ2FwO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IG9wdGlvbnMucXVldWVDbGFzcygpO1xuICAgICAgICB0aGlzLl9xdWV1ZUNsYXNzID0gb3B0aW9ucy5xdWV1ZUNsYXNzO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbmN5ID0gb3B0aW9ucy5jb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgdGhpcy5fdGhyb3dPblRpbWVvdXQgPSBvcHRpb25zLnRocm93T25UaW1lb3V0ID09PSB0cnVlO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IG9wdGlvbnMuYXV0b1N0YXJ0ID09PSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IF9kb2VzSW50ZXJ2YWxBbGxvd0Fub3RoZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0ludGVydmFsSWdub3JlZCB8fCB0aGlzLl9pbnRlcnZhbENvdW50IDwgdGhpcy5faW50ZXJ2YWxDYXA7XG4gICAgfVxuICAgIGdldCBfZG9lc0NvbmN1cnJlbnRBbGxvd0Fub3RoZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQgPCB0aGlzLl9jb25jdXJyZW5jeTtcbiAgICB9XG4gICAgX25leHQoKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudC0tO1xuICAgICAgICB0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpO1xuICAgICAgICB0aGlzLmVtaXQoJ25leHQnKTtcbiAgICB9XG4gICAgX3Jlc29sdmVQcm9taXNlcygpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5KCk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSA9IGVtcHR5O1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlSWRsZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUlkbGUgPSBlbXB0eTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnaWRsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vblJlc3VtZUludGVydmFsKCkge1xuICAgICAgICB0aGlzLl9vbkludGVydmFsKCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX2lzSW50ZXJ2YWxQYXVzZWQoKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5faW50ZXJ2YWxFbmQgLSBub3c7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWN0IGFzIHRoZSBpbnRlcnZhbCB3YXMgZG9uZVxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVzdW1lIGl0IGhlcmUgYmVjYXVzZSBpdCB3aWxsIGJlIHJlc3VtZWQgb24gbGluZSAxNjBcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcnZhbENvdW50ID0gKHRoaXMuX2NhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQpID8gdGhpcy5fcGVuZGluZ0NvdW50IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFjdCBhcyB0aGUgaW50ZXJ2YWwgaXMgcGVuZGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVzdW1lSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF90cnlUb1N0YXJ0QW5vdGhlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBjbGVhciB0aGUgaW50ZXJ2YWwgKFwicGF1c2VcIilcbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2UgY2FuIHJlZG8gaXQgbGF0ZXIgKFwicmVzdW1lXCIpXG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVByb21pc2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuSW5pdGlhbGl6ZUludGVydmFsID0gIXRoaXMuX2lzSW50ZXJ2YWxQYXVzZWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kb2VzSW50ZXJ2YWxBbGxvd0Fub3RoZXIgJiYgdGhpcy5fZG9lc0NvbmN1cnJlbnRBbGxvd0Fub3RoZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSB0aGlzLl9xdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIGpvYigpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5Jbml0aWFsaXplSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUludGVydmFsSWZOZWVkZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZUludGVydmFsSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0ludGVydmFsSWdub3JlZCB8fCB0aGlzLl9pbnRlcnZhbElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25JbnRlcnZhbCgpO1xuICAgICAgICB9LCB0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsRW5kID0gRGF0ZS5ub3coKSArIHRoaXMuX2ludGVydmFsO1xuICAgIH1cbiAgICBfb25JbnRlcnZhbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVydmFsQ291bnQgPT09IDAgJiYgdGhpcy5fcGVuZGluZ0NvdW50ID09PSAwICYmIHRoaXMuX2ludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVydmFsQ291bnQgPSB0aGlzLl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50ID8gdGhpcy5fcGVuZGluZ0NvdW50IDogMDtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4ZWN1dGVzIGFsbCBxdWV1ZWQgZnVuY3Rpb25zIHVudGlsIGl0IHJlYWNoZXMgdGhlIGxpbWl0LlxuICAgICovXG4gICAgX3Byb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIHdoaWxlICh0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpKSB7IH1cbiAgICB9XG4gICAgZ2V0IGNvbmN1cnJlbmN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uY3VycmVuY3k7XG4gICAgfVxuICAgIHNldCBjb25jdXJyZW5jeShuZXdDb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoISh0eXBlb2YgbmV3Q29uY3VycmVuY3kgPT09ICdudW1iZXInICYmIG5ld0NvbmN1cnJlbmN5ID49IDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjb25jdXJyZW5jeVxcYCB0byBiZSBhIG51bWJlciBmcm9tIDEgYW5kIHVwLCBnb3QgXFxgJHtuZXdDb25jdXJyZW5jeX1cXGAgKCR7dHlwZW9mIG5ld0NvbmN1cnJlbmN5fSlgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25jdXJyZW5jeSA9IG5ld0NvbmN1cnJlbmN5O1xuICAgICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkcyBhIHN5bmMgb3IgYXN5bmMgdGFzayB0byB0aGUgcXVldWUuIEFsd2F5cyByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAqL1xuICAgIGFzeW5jIGFkZChmbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxDb3VudCsrO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9ICh0aGlzLl90aW1lb3V0ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQpID8gZm4oKSA6IHBfdGltZW91dF8xLmRlZmF1bHQoUHJvbWlzZS5yZXNvbHZlKGZuKCkpLCAob3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQgPyB0aGlzLl90aW1lb3V0IDogb3B0aW9ucy50aW1lb3V0KSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGhyb3dPblRpbWVvdXQgPT09IHVuZGVmaW5lZCA/IHRoaXMuX3Rocm93T25UaW1lb3V0IDogb3B0aW9ucy50aHJvd09uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aW1lb3V0RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXdhaXQgb3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX25leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5lbnF1ZXVlKHJ1biwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdhZGQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNhbWUgYXMgYC5hZGQoKWAsIGJ1dCBhY2NlcHRzIGFuIGFycmF5IG9mIHN5bmMgb3IgYXN5bmMgZnVuY3Rpb25zLlxuXG4gICAgQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgZnVuY3Rpb25zIGFyZSByZXNvbHZlZC5cbiAgICAqL1xuICAgIGFzeW5jIGFkZEFsbChmdW5jdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZ1bmN0aW9ucy5tYXAoYXN5bmMgKGZ1bmN0aW9uXykgPT4gdGhpcy5hZGQoZnVuY3Rpb25fLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCAob3IgcmVzdW1lKSBleGVjdXRpbmcgZW5xdWV1ZWQgdGFza3Mgd2l0aGluIGNvbmN1cnJlbmN5IGxpbWl0LiBObyBuZWVkIHRvIGNhbGwgdGhpcyBpZiBxdWV1ZSBpcyBub3QgcGF1c2VkICh2aWEgYG9wdGlvbnMuYXV0b1N0YXJ0ID0gZmFsc2VgIG9yIGJ5IGAucGF1c2UoKWAgbWV0aG9kLilcbiAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBxdWV1ZSBleGVjdXRpb24gb24gaG9sZC5cbiAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENsZWFyIHRoZSBxdWV1ZS5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyB0aGlzLl9xdWV1ZUNsYXNzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuIFVzZWZ1bCBpZiB5b3UgZm9yIGV4YW1wbGUgYWRkIGFkZGl0aW9uYWwgaXRlbXMgYXQgYSBsYXRlciB0aW1lLlxuXG4gICAgQHJldHVybnMgQSBwcm9taXNlIHRoYXQgc2V0dGxlcyB3aGVuIHRoZSBxdWV1ZSBiZWNvbWVzIGVtcHR5LlxuICAgICovXG4gICAgYXN5bmMgb25FbXB0eSgpIHtcbiAgICAgICAgLy8gSW5zdGFudGx5IHJlc29sdmUgaWYgdGhlIHF1ZXVlIGlzIGVtcHR5XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvbHZlID0gdGhpcy5fcmVzb2x2ZUVtcHR5O1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGlmZmVyZW5jZSB3aXRoIGAub25FbXB0eWAgaXMgdGhhdCBgLm9uSWRsZWAgZ3VhcmFudGVlcyB0aGF0IGFsbCB3b3JrIGZyb20gdGhlIHF1ZXVlIGhhcyBmaW5pc2hlZC4gYC5vbkVtcHR5YCBtZXJlbHkgc2lnbmFscyB0aGF0IHRoZSBxdWV1ZSBpcyBlbXB0eSwgYnV0IGl0IGNvdWxkIG1lYW4gdGhhdCBzb21lIHByb21pc2VzIGhhdmVuJ3QgY29tcGxldGVkIHlldC5cblxuICAgIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHNldHRsZXMgd2hlbiB0aGUgcXVldWUgYmVjb21lcyBlbXB0eSwgYW5kIGFsbCBwcm9taXNlcyBoYXZlIGNvbXBsZXRlZDsgYHF1ZXVlLnNpemUgPT09IDAgJiYgcXVldWUucGVuZGluZyA9PT0gMGAuXG4gICAgKi9cbiAgICBhc3luYyBvbklkbGUoKSB7XG4gICAgICAgIC8vIEluc3RhbnRseSByZXNvbHZlIGlmIG5vbmUgcGVuZGluZyBhbmQgaWYgbm90aGluZyBlbHNlIGlzIHF1ZXVlZFxuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50ID09PSAwICYmIHRoaXMuX3F1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Jlc29sdmUgPSB0aGlzLl9yZXNvbHZlSWRsZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVJZGxlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBTaXplIG9mIHRoZSBxdWV1ZS5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2l6ZSBvZiB0aGUgcXVldWUsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBvcHRpb25zLlxuXG4gICAgRm9yIGV4YW1wbGUsIHRoaXMgY2FuIGJlIHVzZWQgdG8gZmluZCB0aGUgbnVtYmVyIG9mIGl0ZW1zIHJlbWFpbmluZyBpbiB0aGUgcXVldWUgd2l0aCBhIHNwZWNpZmljIHByaW9yaXR5IGxldmVsLlxuICAgICovXG4gICAgc2l6ZUJ5KG9wdGlvbnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tZm4tcmVmZXJlbmNlLWluLWl0ZXJhdG9yXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5maWx0ZXIob3B0aW9ucykubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBOdW1iZXIgb2YgcGVuZGluZyBwcm9taXNlcy5cbiAgICAqL1xuICAgIGdldCBwZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICovXG4gICAgZ2V0IGlzUGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQYXVzZWQ7XG4gICAgfVxuICAgIGdldCB0aW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0aW1lb3V0IGZvciBmdXR1cmUgb3BlcmF0aW9ucy5cbiAgICAqL1xuICAgIHNldCB0aW1lb3V0KG1pbGxpc2Vjb25kcykge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbWlsbGlzZWNvbmRzO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBRdWV1ZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJwX3RpbWVvdXRfMSIsInByaW9yaXR5X3F1ZXVlXzEiLCJlbXB0eSIsInRpbWVvdXRFcnJvciIsIlRpbWVvdXRFcnJvciIsIlBRdWV1ZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2ludGVydmFsQ291bnQiLCJfaW50ZXJ2YWxFbmQiLCJfcGVuZGluZ0NvdW50IiwiX3Jlc29sdmVFbXB0eSIsIl9yZXNvbHZlSWRsZSIsImFzc2lnbiIsImNhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQiLCJpbnRlcnZhbENhcCIsIkluZmluaXR5IiwiaW50ZXJ2YWwiLCJjb25jdXJyZW5jeSIsImF1dG9TdGFydCIsInF1ZXVlQ2xhc3MiLCJkZWZhdWx0IiwiVHlwZUVycm9yIiwidG9TdHJpbmciLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50IiwiX2lzSW50ZXJ2YWxJZ25vcmVkIiwiX2ludGVydmFsQ2FwIiwiX2ludGVydmFsIiwiX3F1ZXVlIiwiX3F1ZXVlQ2xhc3MiLCJfdGltZW91dCIsInRpbWVvdXQiLCJfdGhyb3dPblRpbWVvdXQiLCJ0aHJvd09uVGltZW91dCIsIl9pc1BhdXNlZCIsIl9kb2VzSW50ZXJ2YWxBbGxvd0Fub3RoZXIiLCJfZG9lc0NvbmN1cnJlbnRBbGxvd0Fub3RoZXIiLCJfY29uY3VycmVuY3kiLCJfbmV4dCIsIl90cnlUb1N0YXJ0QW5vdGhlciIsImVtaXQiLCJfcmVzb2x2ZVByb21pc2VzIiwiX29uUmVzdW1lSW50ZXJ2YWwiLCJfb25JbnRlcnZhbCIsIl9pbml0aWFsaXplSW50ZXJ2YWxJZk5lZWRlZCIsIl90aW1lb3V0SWQiLCJfaXNJbnRlcnZhbFBhdXNlZCIsIm5vdyIsIkRhdGUiLCJfaW50ZXJ2YWxJZCIsImRlbGF5Iiwic2V0VGltZW91dCIsInNpemUiLCJjbGVhckludGVydmFsIiwiY2FuSW5pdGlhbGl6ZUludGVydmFsIiwiam9iIiwiZGVxdWV1ZSIsInNldEludGVydmFsIiwiX3Byb2Nlc3NRdWV1ZSIsIm5ld0NvbmN1cnJlbmN5IiwiYWRkIiwiZm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJ1biIsIm9wZXJhdGlvbiIsImVycm9yIiwiZW5xdWV1ZSIsImFkZEFsbCIsImZ1bmN0aW9ucyIsImFsbCIsIm1hcCIsImZ1bmN0aW9uXyIsInN0YXJ0IiwicGF1c2UiLCJjbGVhciIsIm9uRW1wdHkiLCJleGlzdGluZ1Jlc29sdmUiLCJvbklkbGUiLCJzaXplQnkiLCJmaWx0ZXIiLCJsZW5ndGgiLCJwZW5kaW5nIiwiaXNQYXVzZWQiLCJtaWxsaXNlY29uZHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/p-queue/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/p-queue/dist/lower-bound.js":
/*!**************************************************!*\
  !*** ./node_modules/p-queue/dist/lower-bound.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while(count > 0){\n        const step = count / 2 | 0;\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        } else {\n            count = step;\n        }\n    }\n    return first;\n}\nexports[\"default\"] = lowerBound;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L2xvd2VyLWJvdW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELG1GQUFtRjtBQUNuRix1RUFBdUU7QUFDdkUsU0FBU0MsV0FBV0MsS0FBSyxFQUFFRixLQUFLLEVBQUVHLFVBQVU7SUFDeEMsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFFBQVFILE1BQU1JLE1BQU07SUFDeEIsTUFBT0QsUUFBUSxFQUFHO1FBQ2QsTUFBTUUsT0FBTyxRQUFTLElBQUs7UUFDM0IsSUFBSUMsS0FBS0osUUFBUUc7UUFDakIsSUFBSUosV0FBV0QsS0FBSyxDQUFDTSxHQUFHLEVBQUVSLFVBQVUsR0FBRztZQUNuQ0ksUUFBUSxFQUFFSTtZQUNWSCxTQUFTRSxPQUFPO1FBQ3BCLE9BQ0s7WUFDREYsUUFBUUU7UUFDWjtJQUNKO0lBQ0EsT0FBT0g7QUFDWDtBQUNBTCxrQkFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2JldHRlci10b2RvLy4vbm9kZV9tb2R1bGVzL3AtcXVldWUvZGlzdC9sb3dlci1ib3VuZC5qcz80N2ViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gUG9ydCBvZiBsb3dlcl9ib3VuZCBmcm9tIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2NwcC9hbGdvcml0aG0vbG93ZXJfYm91bmRcbi8vIFVzZWQgdG8gY29tcHV0ZSBpbnNlcnRpb24gaW5kZXggdG8ga2VlcCBxdWV1ZSBzb3J0ZWQgYWZ0ZXIgaW5zZXJ0aW9uXG5mdW5jdGlvbiBsb3dlckJvdW5kKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIGxldCBmaXJzdCA9IDA7XG4gICAgbGV0IGNvdW50ID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IChjb3VudCAvIDIpIHwgMDtcbiAgICAgICAgbGV0IGl0ID0gZmlyc3QgKyBzdGVwO1xuICAgICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpdF0sIHZhbHVlKSA8PSAwKSB7XG4gICAgICAgICAgICBmaXJzdCA9ICsraXQ7XG4gICAgICAgICAgICBjb3VudCAtPSBzdGVwICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50ID0gc3RlcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlyc3Q7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBsb3dlckJvdW5kO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibG93ZXJCb3VuZCIsImFycmF5IiwiY29tcGFyYXRvciIsImZpcnN0IiwiY291bnQiLCJsZW5ndGgiLCJzdGVwIiwiaXQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/p-queue/dist/lower-bound.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/p-queue/dist/priority-queue.js":
/*!*****************************************************!*\
  !*** ./node_modules/p-queue/dist/priority-queue.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst lower_bound_1 = __webpack_require__(/*! ./lower-bound */ \"(rsc)/./node_modules/p-queue/dist/lower-bound.js\");\nclass PriorityQueue {\n    constructor(){\n        this._queue = [];\n    }\n    enqueue(run, options) {\n        options = Object.assign({\n            priority: 0\n        }, options);\n        const element = {\n            priority: options.priority,\n            run\n        };\n        if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n            this._queue.push(element);\n            return;\n        }\n        const index = lower_bound_1.default(this._queue, element, (a, b)=>b.priority - a.priority);\n        this._queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this._queue.shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return this._queue.filter((element)=>element.priority === options.priority).map((element)=>element.run);\n    }\n    get size() {\n        return this._queue.length;\n    }\n}\nexports[\"default\"] = PriorityQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L3ByaW9yaXR5LXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsdUVBQWU7QUFDN0MsTUFBTUM7SUFDRkMsYUFBYztRQUNWLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUU7SUFDcEI7SUFDQUMsUUFBUUMsR0FBRyxFQUFFQyxPQUFPLEVBQUU7UUFDbEJBLFVBQVVYLE9BQU9ZLE1BQU0sQ0FBQztZQUFFQyxVQUFVO1FBQUUsR0FBR0Y7UUFDekMsTUFBTUcsVUFBVTtZQUNaRCxVQUFVRixRQUFRRSxRQUFRO1lBQzFCSDtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNLLElBQUksSUFBSSxJQUFJLENBQUNQLE1BQU0sQ0FBQyxJQUFJLENBQUNPLElBQUksR0FBRyxFQUFFLENBQUNGLFFBQVEsSUFBSUYsUUFBUUUsUUFBUSxFQUFFO1lBQ3RFLElBQUksQ0FBQ0wsTUFBTSxDQUFDUSxJQUFJLENBQUNGO1lBQ2pCO1FBQ0o7UUFDQSxNQUFNRyxRQUFRYixjQUFjYyxPQUFPLENBQUMsSUFBSSxDQUFDVixNQUFNLEVBQUVNLFNBQVMsQ0FBQ0ssR0FBR0MsSUFBTUEsRUFBRVAsUUFBUSxHQUFHTSxFQUFFTixRQUFRO1FBQzNGLElBQUksQ0FBQ0wsTUFBTSxDQUFDYSxNQUFNLENBQUNKLE9BQU8sR0FBR0g7SUFDakM7SUFDQVEsVUFBVTtRQUNOLE1BQU1DLE9BQU8sSUFBSSxDQUFDZixNQUFNLENBQUNnQixLQUFLO1FBQzlCLE9BQU9ELFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLYixHQUFHO0lBQy9EO0lBQ0FlLE9BQU9kLE9BQU8sRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDSCxNQUFNLENBQUNpQixNQUFNLENBQUMsQ0FBQ1gsVUFBWUEsUUFBUUQsUUFBUSxLQUFLRixRQUFRRSxRQUFRLEVBQUVhLEdBQUcsQ0FBQyxDQUFDWixVQUFZQSxRQUFRSixHQUFHO0lBQzlHO0lBQ0EsSUFBSUssT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDUCxNQUFNLENBQUNtQixNQUFNO0lBQzdCO0FBQ0o7QUFDQXpCLGtCQUFlLEdBQUdJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmV0dGVyLXRvZG8vLi9ub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L3ByaW9yaXR5LXF1ZXVlLmpzP2E3NzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBsb3dlcl9ib3VuZF8xID0gcmVxdWlyZShcIi4vbG93ZXItYm91bmRcIik7XG5jbGFzcyBQcmlvcml0eVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB9XG4gICAgZW5xdWV1ZShydW4sIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBwcmlvcml0eTogMCB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIHByaW9yaXR5OiBvcHRpb25zLnByaW9yaXR5LFxuICAgICAgICAgICAgcnVuXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnNpemUgJiYgdGhpcy5fcXVldWVbdGhpcy5zaXplIC0gMV0ucHJpb3JpdHkgPj0gb3B0aW9ucy5wcmlvcml0eSkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IGxvd2VyX2JvdW5kXzEuZGVmYXVsdCh0aGlzLl9xdWV1ZSwgZWxlbWVudCwgKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcbiAgICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGluZGV4LCAwLCBlbGVtZW50KTtcbiAgICB9XG4gICAgZGVxdWV1ZSgpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0ucnVuO1xuICAgIH1cbiAgICBmaWx0ZXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuZmlsdGVyKChlbGVtZW50KSA9PiBlbGVtZW50LnByaW9yaXR5ID09PSBvcHRpb25zLnByaW9yaXR5KS5tYXAoKGVsZW1lbnQpID0+IGVsZW1lbnQucnVuKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUHJpb3JpdHlRdWV1ZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImxvd2VyX2JvdW5kXzEiLCJyZXF1aXJlIiwiUHJpb3JpdHlRdWV1ZSIsImNvbnN0cnVjdG9yIiwiX3F1ZXVlIiwiZW5xdWV1ZSIsInJ1biIsIm9wdGlvbnMiLCJhc3NpZ24iLCJwcmlvcml0eSIsImVsZW1lbnQiLCJzaXplIiwicHVzaCIsImluZGV4IiwiZGVmYXVsdCIsImEiLCJiIiwic3BsaWNlIiwiZGVxdWV1ZSIsIml0ZW0iLCJzaGlmdCIsImZpbHRlciIsIm1hcCIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/p-queue/dist/priority-queue.js\n");

/***/ })

};
;