"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mustache";
exports.ids = ["vendor-chunks/mustache"];
exports.modules = {

/***/ "(rsc)/./node_modules/mustache/mustache.mjs":
/*!********************************************!*\
  !*** ./node_modules/mustache/mustache.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */ var objectToString = Object.prototype.toString;\nvar isArray = Array.isArray || function isArrayPolyfill(object) {\n    return objectToString.call(object) === \"[object Array]\";\n};\nfunction isFunction(object) {\n    return typeof object === \"function\";\n}\n/**\n * More correct typeof string handling array\n * which normally returns typeof 'object'\n */ function typeStr(obj) {\n    return isArray(obj) ? \"array\" : typeof obj;\n}\nfunction escapeRegExp(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n}\n/**\n * Null safe way of checking whether or not an object,\n * including its prototype, has a given property\n */ function hasProperty(obj, propName) {\n    return obj != null && typeof obj === \"object\" && propName in obj;\n}\n/**\n * Safe way of detecting whether or not the given thing is a primitive and\n * whether it has the given property\n */ function primitiveHasOwnProperty(primitive, propName) {\n    return primitive != null && typeof primitive !== \"object\" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);\n}\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n// See https://github.com/janl/mustache.js/issues/189\nvar regExpTest = RegExp.prototype.test;\nfunction testRegExp(re, string) {\n    return regExpTest.call(re, string);\n}\nvar nonSpaceRe = /\\S/;\nfunction isWhitespace(string) {\n    return !testRegExp(nonSpaceRe, string);\n}\nvar entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\",\n    \"`\": \"&#x60;\",\n    \"=\": \"&#x3D;\"\n};\nfunction escapeHtml(string) {\n    return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap(s) {\n        return entityMap[s];\n    });\n}\nvar whiteRe = /\\s*/;\nvar spaceRe = /\\s+/;\nvar equalsRe = /\\s*=/;\nvar curlyRe = /\\s*\\}/;\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n/**\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\n * argument is given here it must be an array with two string values: the\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n * course, the default is to use mustaches (i.e. mustache.tags).\n *\n * A token is an array with at least 4 elements. The first element is the\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n * all text that appears outside a symbol this element is \"text\".\n *\n * The second element of a token is its \"value\". For mustache tags this is\n * whatever else was inside the tag besides the opening symbol. For text tokens\n * this is the text itself.\n *\n * The third and fourth elements of the token are the start and end indices,\n * respectively, of the token in the original template.\n *\n * Tokens that are the root node of a subtree contain two more elements: 1) an\n * array of tokens in the subtree and 2) the index in the original template at\n * which the closing tag for that section begins.\n *\n * Tokens for partials also contain two more elements: 1) a string value of\n * indendation prior to that tag and 2) the index of that tag on that line -\n * eg a value of 2 indicates the partial is the third tag on this line.\n */ function parseTemplate(template, tags) {\n    if (!template) return [];\n    var lineHasNonSpace = false;\n    var sections = []; // Stack to hold section tokens\n    var tokens = []; // Buffer to hold the tokens\n    var spaces = []; // Indices of whitespace tokens on the current line\n    var hasTag = false; // Is there a {{tag}} on the current line?\n    var nonSpace = false; // Is there a non-space char on the current line?\n    var indentation = \"\"; // Tracks indentation for tags that use it\n    var tagIndex = 0; // Stores a count of number of tags encountered on a line\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n        if (hasTag && !nonSpace) {\n            while(spaces.length)delete tokens[spaces.pop()];\n        } else {\n            spaces = [];\n        }\n        hasTag = false;\n        nonSpace = false;\n    }\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags(tagsToCompile) {\n        if (typeof tagsToCompile === \"string\") tagsToCompile = tagsToCompile.split(spaceRe, 2);\n        if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error(\"Invalid tags: \" + tagsToCompile);\n        openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + \"\\\\s*\");\n        closingTagRe = new RegExp(\"\\\\s*\" + escapeRegExp(tagsToCompile[1]));\n        closingCurlyRe = new RegExp(\"\\\\s*\" + escapeRegExp(\"}\" + tagsToCompile[1]));\n    }\n    compileTags(tags || mustache.tags);\n    var scanner = new Scanner(template);\n    var start, type, value, chr, token, openSection;\n    while(!scanner.eos()){\n        start = scanner.pos;\n        // Match any text between tags.\n        value = scanner.scanUntil(openingTagRe);\n        if (value) {\n            for(var i = 0, valueLength = value.length; i < valueLength; ++i){\n                chr = value.charAt(i);\n                if (isWhitespace(chr)) {\n                    spaces.push(tokens.length);\n                    indentation += chr;\n                } else {\n                    nonSpace = true;\n                    lineHasNonSpace = true;\n                    indentation += \" \";\n                }\n                tokens.push([\n                    \"text\",\n                    chr,\n                    start,\n                    start + 1\n                ]);\n                start += 1;\n                // Check for whitespace on the current line.\n                if (chr === \"\\n\") {\n                    stripSpace();\n                    indentation = \"\";\n                    tagIndex = 0;\n                    lineHasNonSpace = false;\n                }\n            }\n        }\n        // Match the opening tag.\n        if (!scanner.scan(openingTagRe)) break;\n        hasTag = true;\n        // Get the tag type.\n        type = scanner.scan(tagRe) || \"name\";\n        scanner.scan(whiteRe);\n        // Get the tag value.\n        if (type === \"=\") {\n            value = scanner.scanUntil(equalsRe);\n            scanner.scan(equalsRe);\n            scanner.scanUntil(closingTagRe);\n        } else if (type === \"{\") {\n            value = scanner.scanUntil(closingCurlyRe);\n            scanner.scan(curlyRe);\n            scanner.scanUntil(closingTagRe);\n            type = \"&\";\n        } else {\n            value = scanner.scanUntil(closingTagRe);\n        }\n        // Match the closing tag.\n        if (!scanner.scan(closingTagRe)) throw new Error(\"Unclosed tag at \" + scanner.pos);\n        if (type == \">\") {\n            token = [\n                type,\n                value,\n                start,\n                scanner.pos,\n                indentation,\n                tagIndex,\n                lineHasNonSpace\n            ];\n        } else {\n            token = [\n                type,\n                value,\n                start,\n                scanner.pos\n            ];\n        }\n        tagIndex++;\n        tokens.push(token);\n        if (type === \"#\" || type === \"^\") {\n            sections.push(token);\n        } else if (type === \"/\") {\n            // Check section nesting.\n            openSection = sections.pop();\n            if (!openSection) throw new Error('Unopened section \"' + value + '\" at ' + start);\n            if (openSection[1] !== value) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n        } else if (type === \"name\" || type === \"{\" || type === \"&\") {\n            nonSpace = true;\n        } else if (type === \"=\") {\n            // Set the tags for the next time around.\n            compileTags(value);\n        }\n    }\n    stripSpace();\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n    if (openSection) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n    return nestTokens(squashTokens(tokens));\n}\n/**\n * Combines the values of consecutive text tokens in the given `tokens` array\n * to a single token.\n */ function squashTokens(tokens) {\n    var squashedTokens = [];\n    var token, lastToken;\n    for(var i = 0, numTokens = tokens.length; i < numTokens; ++i){\n        token = tokens[i];\n        if (token) {\n            if (token[0] === \"text\" && lastToken && lastToken[0] === \"text\") {\n                lastToken[1] += token[1];\n                lastToken[3] = token[3];\n            } else {\n                squashedTokens.push(token);\n                lastToken = token;\n            }\n        }\n    }\n    return squashedTokens;\n}\n/**\n * Forms the given array of `tokens` into a nested tree structure where\n * tokens that represent a section have two additional items: 1) an array of\n * all tokens that appear in that section and 2) the index in the original\n * template that represents the end of that section.\n */ function nestTokens(tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n    var token, section;\n    for(var i = 0, numTokens = tokens.length; i < numTokens; ++i){\n        token = tokens[i];\n        switch(token[0]){\n            case \"#\":\n            case \"^\":\n                collector.push(token);\n                sections.push(token);\n                collector = token[4] = [];\n                break;\n            case \"/\":\n                section = sections.pop();\n                section[5] = token[2];\n                collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n                break;\n            default:\n                collector.push(token);\n        }\n    }\n    return nestedTokens;\n}\n/**\n * A simple string scanner that is used by the template parser to find\n * tokens in template strings.\n */ function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n}\n/**\n * Returns `true` if the tail is empty (end of string).\n */ Scanner.prototype.eos = function eos() {\n    return this.tail === \"\";\n};\n/**\n * Tries to match the given regular expression at the current position.\n * Returns the matched text if it can match, the empty string otherwise.\n */ Scanner.prototype.scan = function scan(re) {\n    var match = this.tail.match(re);\n    if (!match || match.index !== 0) return \"\";\n    var string = match[0];\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n    return string;\n};\n/**\n * Skips all text until the given regular expression can be matched. Returns\n * the skipped string, which is the entire tail if no match can be made.\n */ Scanner.prototype.scanUntil = function scanUntil(re) {\n    var index = this.tail.search(re), match;\n    switch(index){\n        case -1:\n            match = this.tail;\n            this.tail = \"\";\n            break;\n        case 0:\n            match = \"\";\n            break;\n        default:\n            match = this.tail.substring(0, index);\n            this.tail = this.tail.substring(index);\n    }\n    this.pos += match.length;\n    return match;\n};\n/**\n * Represents a rendering context by wrapping a view object and\n * maintaining a reference to the parent context.\n */ function Context(view, parentContext) {\n    this.view = view;\n    this.cache = {\n        \".\": this.view\n    };\n    this.parent = parentContext;\n}\n/**\n * Creates a new context using the given view with this context\n * as the parent.\n */ Context.prototype.push = function push(view) {\n    return new Context(view, this);\n};\n/**\n * Returns the value of the given name in this context, traversing\n * up the context hierarchy if the value is absent in this context's view.\n */ Context.prototype.lookup = function lookup(name) {\n    var cache1 = this.cache;\n    var value;\n    if (cache1.hasOwnProperty(name)) {\n        value = cache1[name];\n    } else {\n        var context = this, intermediateValue, names, index, lookupHit = false;\n        while(context){\n            if (name.indexOf(\".\") > 0) {\n                intermediateValue = context.view;\n                names = name.split(\".\");\n                index = 0;\n                /**\n         * Using the dot notion path in `name`, we descend through the\n         * nested objects.\n         *\n         * To be certain that the lookup has been successful, we have to\n         * check if the last object in the path actually has the property\n         * we are looking for. We store the result in `lookupHit`.\n         *\n         * This is specially necessary for when the value has been set to\n         * `undefined` and we want to avoid looking up parent contexts.\n         *\n         * In the case where dot notation is used, we consider the lookup\n         * to be successful even if the last \"object\" in the path is\n         * not actually an object but a primitive (e.g., a string, or an\n         * integer), because it is sometimes useful to access a property\n         * of an autoboxed primitive, such as the length of a string.\n         **/ while(intermediateValue != null && index < names.length){\n                    if (index === names.length - 1) lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);\n                    intermediateValue = intermediateValue[names[index++]];\n                }\n            } else {\n                intermediateValue = context.view[name];\n                /**\n         * Only checking against `hasProperty`, which always returns `false` if\n         * `context.view` is not an object. Deliberately omitting the check\n         * against `primitiveHasOwnProperty` if dot notation is not used.\n         *\n         * Consider this example:\n         * ```\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n         * ```\n         *\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\n         * in the dot notation case, then render call would return:\n         *\n         * \"The length of a football field is 9.\"\n         *\n         * rather than the expected:\n         *\n         * \"The length of a football field is 100 yards.\"\n         **/ lookupHit = hasProperty(context.view, name);\n            }\n            if (lookupHit) {\n                value = intermediateValue;\n                break;\n            }\n            context = context.parent;\n        }\n        cache1[name] = value;\n    }\n    if (isFunction(value)) value = value.call(this.view);\n    return value;\n};\n/**\n * A Writer knows how to take a stream of tokens and render them to a\n * string, given a context. It also maintains a cache of templates to\n * avoid the need to parse the same template twice.\n */ function Writer() {\n    this.templateCache = {\n        _cache: {},\n        set: function set(key, value) {\n            this._cache[key] = value;\n        },\n        get: function get(key) {\n            return this._cache[key];\n        },\n        clear: function clear() {\n            this._cache = {};\n        }\n    };\n}\n/**\n * Clears all cached templates in this writer.\n */ Writer.prototype.clearCache = function clearCache() {\n    if (typeof this.templateCache !== \"undefined\") {\n        this.templateCache.clear();\n    }\n};\n/**\n * Parses and caches the given `template` according to the given `tags` or\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n * that is generated from the parse.\n */ Writer.prototype.parse = function parse(template, tags) {\n    var cache1 = this.templateCache;\n    var cacheKey = template + \":\" + (tags || mustache.tags).join(\":\");\n    var isCacheEnabled = typeof cache1 !== \"undefined\";\n    var tokens = isCacheEnabled ? cache1.get(cacheKey) : undefined;\n    if (tokens == undefined) {\n        tokens = parseTemplate(template, tags);\n        isCacheEnabled && cache1.set(cacheKey, tokens);\n    }\n    return tokens;\n};\n/**\n * High-level method that is used to render the given `template` with\n * the given `view`.\n *\n * The optional `partials` argument may be an object that contains the\n * names and templates of partials that are used in the template. It may\n * also be a function that is used to load partial templates on the fly\n * that takes a single argument: the name of the partial.\n *\n * If the optional `config` argument is given here, then it should be an\n * object with a `tags` attribute or an `escape` attribute or both.\n * If an array is passed, then it will be interpreted the same way as\n * a `tags` attribute on a `config` object.\n *\n * The `tags` attribute of a `config` object must be an array with two\n * string values: the opening and closing tags used in the template (e.g.\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n *\n * The `escape` attribute of a `config` object must be a function which\n * accepts a string as input and outputs a safely escaped string.\n * If an `escape` function is not provided, then an HTML-safe string\n * escaping function is used as the default.\n */ Writer.prototype.render = function render(template, view, partials, config) {\n    var tags = this.getConfigTags(config);\n    var tokens = this.parse(template, tags);\n    var context = view instanceof Context ? view : new Context(view, undefined);\n    return this.renderTokens(tokens, context, partials, template, config);\n};\n/**\n * Low-level method that renders the given array of `tokens` using\n * the given `context` and `partials`.\n *\n * Note: The `originalTemplate` is only ever used to extract the portion\n * of the original template that was contained in a higher-order section.\n * If the template doesn't use higher-order sections, this argument may\n * be omitted.\n */ Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {\n    var buffer = \"\";\n    var token, symbol, value;\n    for(var i = 0, numTokens = tokens.length; i < numTokens; ++i){\n        value = undefined;\n        token = tokens[i];\n        symbol = token[0];\n        if (symbol === \"#\") value = this.renderSection(token, context, partials, originalTemplate, config);\n        else if (symbol === \"^\") value = this.renderInverted(token, context, partials, originalTemplate, config);\n        else if (symbol === \">\") value = this.renderPartial(token, context, partials, config);\n        else if (symbol === \"&\") value = this.unescapedValue(token, context);\n        else if (symbol === \"name\") value = this.escapedValue(token, context, config);\n        else if (symbol === \"text\") value = this.rawValue(token);\n        if (value !== undefined) buffer += value;\n    }\n    return buffer;\n};\nWriter.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {\n    var self = this;\n    var buffer = \"\";\n    var value = context.lookup(token[1]);\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender(template) {\n        return self.render(template, context, partials, config);\n    }\n    if (!value) return;\n    if (isArray(value)) {\n        for(var j = 0, valueLength = value.length; j < valueLength; ++j){\n            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\n        }\n    } else if (typeof value === \"object\" || typeof value === \"string\" || typeof value === \"number\") {\n        buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\n    } else if (isFunction(value)) {\n        if (typeof originalTemplate !== \"string\") throw new Error(\"Cannot use higher-order sections without the original template\");\n        // Extract the portion of the original template that the section contains.\n        value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n        if (value != null) buffer += value;\n    } else {\n        buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\n    }\n    return buffer;\n};\nWriter.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {\n    var value = context.lookup(token[1]);\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate, config);\n};\nWriter.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {\n    var filteredIndentation = indentation.replace(/[^ \\t]/g, \"\");\n    var partialByNl = partial.split(\"\\n\");\n    for(var i = 0; i < partialByNl.length; i++){\n        if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n            partialByNl[i] = filteredIndentation + partialByNl[i];\n        }\n    }\n    return partialByNl.join(\"\\n\");\n};\nWriter.prototype.renderPartial = function renderPartial(token, context, partials, config) {\n    if (!partials) return;\n    var tags = this.getConfigTags(config);\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null) {\n        var lineHasNonSpace = token[6];\n        var tagIndex = token[5];\n        var indentation = token[4];\n        var indentedValue = value;\n        if (tagIndex == 0 && indentation) {\n            indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n        }\n        var tokens = this.parse(indentedValue, tags);\n        return this.renderTokens(tokens, context, partials, indentedValue, config);\n    }\n};\nWriter.prototype.unescapedValue = function unescapedValue(token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null) return value;\n};\nWriter.prototype.escapedValue = function escapedValue(token, context, config) {\n    var escape = this.getConfigEscape(config) || mustache.escape;\n    var value = context.lookup(token[1]);\n    if (value != null) return typeof value === \"number\" && escape === mustache.escape ? String(value) : escape(value);\n};\nWriter.prototype.rawValue = function rawValue(token) {\n    return token[1];\n};\nWriter.prototype.getConfigTags = function getConfigTags(config) {\n    if (isArray(config)) {\n        return config;\n    } else if (config && typeof config === \"object\") {\n        return config.tags;\n    } else {\n        return undefined;\n    }\n};\nWriter.prototype.getConfigEscape = function getConfigEscape(config) {\n    if (config && typeof config === \"object\" && !isArray(config)) {\n        return config.escape;\n    } else {\n        return undefined;\n    }\n};\nvar mustache = {\n    name: \"mustache.js\",\n    version: \"4.2.0\",\n    tags: [\n        \"{{\",\n        \"}}\"\n    ],\n    clearCache: undefined,\n    escape: undefined,\n    parse: undefined,\n    render: undefined,\n    Scanner: undefined,\n    Context: undefined,\n    Writer: undefined,\n    /**\n   * Allows a user to override the default caching strategy, by providing an\n   * object with set, get and clear methods. This can also be used to disable\n   * the cache by setting it to the literal `undefined`.\n   */ set templateCache (cache){\n        defaultWriter.templateCache = cache;\n    },\n    /**\n   * Gets the default or overridden caching object from the default writer.\n   */ get templateCache () {\n        return defaultWriter.templateCache;\n    }\n};\n// All high-level mustache.* functions use this writer.\nvar defaultWriter = new Writer();\n/**\n * Clears all cached templates in the default writer.\n */ mustache.clearCache = function clearCache() {\n    return defaultWriter.clearCache();\n};\n/**\n * Parses and caches the given template in the default writer and returns the\n * array of tokens it contains. Doing this ahead of time avoids the need to\n * parse templates on the fly as they are rendered.\n */ mustache.parse = function parse(template, tags) {\n    return defaultWriter.parse(template, tags);\n};\n/**\n * Renders the `template` with the given `view`, `partials`, and `config`\n * using the default writer.\n */ mustache.render = function render(template, view, partials, config) {\n    if (typeof template !== \"string\") {\n        throw new TypeError('Invalid template! Template should be a \"string\" ' + 'but \"' + typeStr(template) + '\" was given as the first ' + \"argument for mustache#render(template, view, partials)\");\n    }\n    return defaultWriter.render(template, view, partials, config);\n};\n// Export the escaping function so that the user may override it.\n// See https://github.com/janl/mustache.js/issues/244\nmustache.escape = escapeHtml;\n// Export these mainly for testing, but also for advanced usage.\nmustache.Scanner = Scanner;\nmustache.Context = Context;\nmustache.Writer = Writer;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mustache);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbXVzdGFjaGUvbXVzdGFjaGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FFRCxJQUFJQSxpQkFBaUJDLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUTtBQUM5QyxJQUFJQyxVQUFVQyxNQUFNRCxPQUFPLElBQUksU0FBU0UsZ0JBQWlCQyxNQUFNO0lBQzdELE9BQU9QLGVBQWVRLElBQUksQ0FBQ0QsWUFBWTtBQUN6QztBQUVBLFNBQVNFLFdBQVlGLE1BQU07SUFDekIsT0FBTyxPQUFPQSxXQUFXO0FBQzNCO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0csUUFBU0MsR0FBRztJQUNuQixPQUFPUCxRQUFRTyxPQUFPLFVBQVUsT0FBT0E7QUFDekM7QUFFQSxTQUFTQyxhQUFjQyxNQUFNO0lBQzNCLE9BQU9BLE9BQU9DLE9BQU8sQ0FBQywrQkFBK0I7QUFDdkQ7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxZQUFhSixHQUFHLEVBQUVLLFFBQVE7SUFDakMsT0FBT0wsT0FBTyxRQUFRLE9BQU9BLFFBQVEsWUFBYUssWUFBWUw7QUFDaEU7QUFFQTs7O0NBR0MsR0FDRCxTQUFTTSx3QkFBeUJDLFNBQVMsRUFBRUYsUUFBUTtJQUNuRCxPQUNFRSxhQUFhLFFBQ1YsT0FBT0EsY0FBYyxZQUNyQkEsVUFBVUMsY0FBYyxJQUN4QkQsVUFBVUMsY0FBYyxDQUFDSDtBQUVoQztBQUVBLG1FQUFtRTtBQUNuRSxxREFBcUQ7QUFDckQsSUFBSUksYUFBYUMsT0FBT25CLFNBQVMsQ0FBQ29CLElBQUk7QUFDdEMsU0FBU0MsV0FBWUMsRUFBRSxFQUFFWCxNQUFNO0lBQzdCLE9BQU9PLFdBQVdaLElBQUksQ0FBQ2dCLElBQUlYO0FBQzdCO0FBRUEsSUFBSVksYUFBYTtBQUNqQixTQUFTQyxhQUFjYixNQUFNO0lBQzNCLE9BQU8sQ0FBQ1UsV0FBV0UsWUFBWVo7QUFDakM7QUFFQSxJQUFJYyxZQUFZO0lBQ2QsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFL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Q3BDO0FBQ0Y7QUFFQSx1REFBdUQ7QUFDdkQsSUFBSXNDLGdCQUFnQixJQUFJdkM7QUFFeEI7O0NBRUMsR0FDRDFDLFNBQVNpRCxVQUFVLEdBQUcsU0FBU0E7SUFDN0IsT0FBT2dDLGNBQWNoQyxVQUFVO0FBQ2pDO0FBRUE7Ozs7Q0FJQyxHQUNEakQsU0FBU2tELEtBQUssR0FBRyxTQUFTQSxNQUFPdEUsUUFBUSxFQUFFQyxJQUFJO0lBQzdDLE9BQU9vRyxjQUFjL0IsS0FBSyxDQUFDdEUsVUFBVUM7QUFDdkM7QUFFQTs7O0NBR0MsR0FDRG1CLFNBQVN1RCxNQUFNLEdBQUcsU0FBU0EsT0FBUTNFLFFBQVEsRUFBRW1ELElBQUksRUFBRXlCLFFBQVEsRUFBRUMsTUFBTTtJQUNqRSxJQUFJLE9BQU83RSxhQUFhLFVBQVU7UUFDaEMsTUFBTSxJQUFJc0csVUFBVSxxREFDQSxVQUFVbEksUUFBUTRCLFlBQVksOEJBQzlCO0lBQ3RCO0lBRUEsT0FBT3FHLGNBQWMxQixNQUFNLENBQUMzRSxVQUFVbUQsTUFBTXlCLFVBQVVDO0FBQ3hEO0FBRUEsaUVBQWlFO0FBQ2pFLHFEQUFxRDtBQUNyRHpELFNBQVM4RSxNQUFNLEdBQUc1RztBQUVsQixnRUFBZ0U7QUFDaEU4QixTQUFTRSxPQUFPLEdBQUdBO0FBQ25CRixTQUFTOEIsT0FBTyxHQUFHQTtBQUNuQjlCLFNBQVMwQyxNQUFNLEdBQUdBO0FBRWxCLGlFQUFlMUMsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JldHRlci10b2RvLy4vbm9kZV9tb2R1bGVzL211c3RhY2hlL211c3RhY2hlLm1qcz80NDVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogbXVzdGFjaGUuanMgLSBMb2dpYy1sZXNzIHt7bXVzdGFjaGV9fSB0ZW1wbGF0ZXMgd2l0aCBKYXZhU2NyaXB0XG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzXG4gKi9cblxudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5UG9seWZpbGwgKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIE1vcmUgY29ycmVjdCB0eXBlb2Ygc3RyaW5nIGhhbmRsaW5nIGFycmF5XG4gKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICovXG5mdW5jdGlvbiB0eXBlU3RyIChvYmopIHtcbiAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAgKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG59XG5cbi8qKlxuICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gKiBpbmNsdWRpbmcgaXRzIHByb3RvdHlwZSwgaGFzIGEgZ2l2ZW4gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIChwcm9wTmFtZSBpbiBvYmopO1xufVxuXG4vKipcbiAqIFNhZmUgd2F5IG9mIGRldGVjdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdGhpbmcgaXMgYSBwcmltaXRpdmUgYW5kXG4gKiB3aGV0aGVyIGl0IGhhcyB0aGUgZ2l2ZW4gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gcHJpbWl0aXZlSGFzT3duUHJvcGVydHkgKHByaW1pdGl2ZSwgcHJvcE5hbWUpIHtcbiAgcmV0dXJuIChcbiAgICBwcmltaXRpdmUgIT0gbnVsbFxuICAgICYmIHR5cGVvZiBwcmltaXRpdmUgIT09ICdvYmplY3QnXG4gICAgJiYgcHJpbWl0aXZlLmhhc093blByb3BlcnR5XG4gICAgJiYgcHJpbWl0aXZlLmhhc093blByb3BlcnR5KHByb3BOYW1lKVxuICApO1xufVxuXG4vLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2lzc3Vlcy5hcGFjaGUub3JnL2ppcmEvYnJvd3NlL0NPVUNIREItNTc3XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4OVxudmFyIHJlZ0V4cFRlc3QgPSBSZWdFeHAucHJvdG90eXBlLnRlc3Q7XG5mdW5jdGlvbiB0ZXN0UmVnRXhwIChyZSwgc3RyaW5nKSB7XG4gIHJldHVybiByZWdFeHBUZXN0LmNhbGwocmUsIHN0cmluZyk7XG59XG5cbnZhciBub25TcGFjZVJlID0gL1xcUy87XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKHN0cmluZykge1xuICByZXR1cm4gIXRlc3RSZWdFeHAobm9uU3BhY2VSZSwgc3RyaW5nKTtcbn1cblxudmFyIGVudGl0eU1hcCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgJy8nOiAnJiN4MkY7JyxcbiAgJ2AnOiAnJiN4NjA7JyxcbiAgJz0nOiAnJiN4M0Q7J1xufTtcblxuZnVuY3Rpb24gZXNjYXBlSHRtbCAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9bJjw+XCInYD1cXC9dL2csIGZ1bmN0aW9uIGZyb21FbnRpdHlNYXAgKHMpIHtcbiAgICByZXR1cm4gZW50aXR5TWFwW3NdO1xuICB9KTtcbn1cblxudmFyIHdoaXRlUmUgPSAvXFxzKi87XG52YXIgc3BhY2VSZSA9IC9cXHMrLztcbnZhciBlcXVhbHNSZSA9IC9cXHMqPS87XG52YXIgY3VybHlSZSA9IC9cXHMqXFx9LztcbnZhciB0YWdSZSA9IC8jfFxcXnxcXC98PnxcXHt8Jnw9fCEvO1xuXG4vKipcbiAqIEJyZWFrcyB1cCB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBzdHJpbmcgaW50byBhIHRyZWUgb2YgdG9rZW5zLiBJZiB0aGUgYHRhZ3NgXG4gKiBhcmd1bWVudCBpcyBnaXZlbiBoZXJlIGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gc3RyaW5nIHZhbHVlczogdGhlXG4gKiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy4gWyBcIjwlXCIsIFwiJT5cIiBdKS4gT2ZcbiAqIGNvdXJzZSwgdGhlIGRlZmF1bHQgaXMgdG8gdXNlIG11c3RhY2hlcyAoaS5lLiBtdXN0YWNoZS50YWdzKS5cbiAqXG4gKiBBIHRva2VuIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgNCBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gKiBtdXN0YWNoZSBzeW1ib2wgdGhhdCB3YXMgdXNlZCBpbnNpZGUgdGhlIHRhZywgZS5nLiBcIiNcIiBvciBcIiZcIi4gSWYgdGhlIHRhZ1xuICogZGlkIG5vdCBjb250YWluIGEgc3ltYm9sIChpLmUuIHt7bXlWYWx1ZX19KSB0aGlzIGVsZW1lbnQgaXMgXCJuYW1lXCIuIEZvclxuICogYWxsIHRleHQgdGhhdCBhcHBlYXJzIG91dHNpZGUgYSBzeW1ib2wgdGhpcyBlbGVtZW50IGlzIFwidGV4dFwiLlxuICpcbiAqIFRoZSBzZWNvbmQgZWxlbWVudCBvZiBhIHRva2VuIGlzIGl0cyBcInZhbHVlXCIuIEZvciBtdXN0YWNoZSB0YWdzIHRoaXMgaXNcbiAqIHdoYXRldmVyIGVsc2Ugd2FzIGluc2lkZSB0aGUgdGFnIGJlc2lkZXMgdGhlIG9wZW5pbmcgc3ltYm9sLiBGb3IgdGV4dCB0b2tlbnNcbiAqIHRoaXMgaXMgdGhlIHRleHQgaXRzZWxmLlxuICpcbiAqIFRoZSB0aGlyZCBhbmQgZm91cnRoIGVsZW1lbnRzIG9mIHRoZSB0b2tlbiBhcmUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyxcbiAqIHJlc3BlY3RpdmVseSwgb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cbiAqXG4gKiBUb2tlbnMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZSBvZiBhIHN1YnRyZWUgY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYW5cbiAqIGFycmF5IG9mIHRva2VucyBpbiB0aGUgc3VidHJlZSBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBhdFxuICogd2hpY2ggdGhlIGNsb3NpbmcgdGFnIGZvciB0aGF0IHNlY3Rpb24gYmVnaW5zLlxuICpcbiAqIFRva2VucyBmb3IgcGFydGlhbHMgYWxzbyBjb250YWluIHR3byBtb3JlIGVsZW1lbnRzOiAxKSBhIHN0cmluZyB2YWx1ZSBvZlxuICogaW5kZW5kYXRpb24gcHJpb3IgdG8gdGhhdCB0YWcgYW5kIDIpIHRoZSBpbmRleCBvZiB0aGF0IHRhZyBvbiB0aGF0IGxpbmUgLVxuICogZWcgYSB2YWx1ZSBvZiAyIGluZGljYXRlcyB0aGUgcGFydGlhbCBpcyB0aGUgdGhpcmQgdGFnIG9uIHRoaXMgbGluZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgaWYgKCF0ZW1wbGF0ZSlcbiAgICByZXR1cm4gW107XG4gIHZhciBsaW5lSGFzTm9uU3BhY2UgPSBmYWxzZTtcbiAgdmFyIHNlY3Rpb25zID0gW107ICAgICAvLyBTdGFjayB0byBob2xkIHNlY3Rpb24gdG9rZW5zXG4gIHZhciB0b2tlbnMgPSBbXTsgICAgICAgLy8gQnVmZmVyIHRvIGhvbGQgdGhlIHRva2Vuc1xuICB2YXIgc3BhY2VzID0gW107ICAgICAgIC8vIEluZGljZXMgb2Ygd2hpdGVzcGFjZSB0b2tlbnMgb24gdGhlIGN1cnJlbnQgbGluZVxuICB2YXIgaGFzVGFnID0gZmFsc2U7ICAgIC8vIElzIHRoZXJlIGEge3t0YWd9fSBvbiB0aGUgY3VycmVudCBsaW5lP1xuICB2YXIgbm9uU3BhY2UgPSBmYWxzZTsgIC8vIElzIHRoZXJlIGEgbm9uLXNwYWNlIGNoYXIgb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgdmFyIGluZGVudGF0aW9uID0gJyc7ICAvLyBUcmFja3MgaW5kZW50YXRpb24gZm9yIHRhZ3MgdGhhdCB1c2UgaXRcbiAgdmFyIHRhZ0luZGV4ID0gMDsgICAgICAvLyBTdG9yZXMgYSBjb3VudCBvZiBudW1iZXIgb2YgdGFncyBlbmNvdW50ZXJlZCBvbiBhIGxpbmVcblxuICAvLyBTdHJpcHMgYWxsIHdoaXRlc3BhY2UgdG9rZW5zIGFycmF5IGZvciB0aGUgY3VycmVudCBsaW5lXG4gIC8vIGlmIHRoZXJlIHdhcyBhIHt7I3RhZ319IG9uIGl0IGFuZCBvdGhlcndpc2Ugb25seSBzcGFjZS5cbiAgZnVuY3Rpb24gc3RyaXBTcGFjZSAoKSB7XG4gICAgaWYgKGhhc1RhZyAmJiAhbm9uU3BhY2UpIHtcbiAgICAgIHdoaWxlIChzcGFjZXMubGVuZ3RoKVxuICAgICAgICBkZWxldGUgdG9rZW5zW3NwYWNlcy5wb3AoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNwYWNlcyA9IFtdO1xuICAgIH1cblxuICAgIGhhc1RhZyA9IGZhbHNlO1xuICAgIG5vblNwYWNlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgb3BlbmluZ1RhZ1JlLCBjbG9zaW5nVGFnUmUsIGNsb3NpbmdDdXJseVJlO1xuICBmdW5jdGlvbiBjb21waWxlVGFncyAodGFnc1RvQ29tcGlsZSkge1xuICAgIGlmICh0eXBlb2YgdGFnc1RvQ29tcGlsZSA9PT0gJ3N0cmluZycpXG4gICAgICB0YWdzVG9Db21waWxlID0gdGFnc1RvQ29tcGlsZS5zcGxpdChzcGFjZVJlLCAyKTtcblxuICAgIGlmICghaXNBcnJheSh0YWdzVG9Db21waWxlKSB8fCB0YWdzVG9Db21waWxlLmxlbmd0aCAhPT0gMilcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWdzOiAnICsgdGFnc1RvQ29tcGlsZSk7XG5cbiAgICBvcGVuaW5nVGFnUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzBdKSArICdcXFxccyonKTtcbiAgICBjbG9zaW5nVGFnUmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgICBjbG9zaW5nQ3VybHlSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1RvQ29tcGlsZVsxXSkpO1xuICB9XG5cbiAgY29tcGlsZVRhZ3ModGFncyB8fCBtdXN0YWNoZS50YWdzKTtcblxuICB2YXIgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRlbXBsYXRlKTtcblxuICB2YXIgc3RhcnQsIHR5cGUsIHZhbHVlLCBjaHIsIHRva2VuLCBvcGVuU2VjdGlvbjtcbiAgd2hpbGUgKCFzY2FubmVyLmVvcygpKSB7XG4gICAgc3RhcnQgPSBzY2FubmVyLnBvcztcblxuICAgIC8vIE1hdGNoIGFueSB0ZXh0IGJldHdlZW4gdGFncy5cbiAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKG9wZW5pbmdUYWdSZSk7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IHZhbHVlTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2hyID0gdmFsdWUuY2hhckF0KGkpO1xuXG4gICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hyKSkge1xuICAgICAgICAgIHNwYWNlcy5wdXNoKHRva2Vucy5sZW5ndGgpO1xuICAgICAgICAgIGluZGVudGF0aW9uICs9IGNocjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgbGluZUhhc05vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbnMucHVzaChbICd0ZXh0JywgY2hyLCBzdGFydCwgc3RhcnQgKyAxIF0pO1xuICAgICAgICBzdGFydCArPSAxO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciB3aGl0ZXNwYWNlIG9uIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgIGlmIChjaHIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgc3RyaXBTcGFjZSgpO1xuICAgICAgICAgIGluZGVudGF0aW9uID0gJyc7XG4gICAgICAgICAgdGFnSW5kZXggPSAwO1xuICAgICAgICAgIGxpbmVIYXNOb25TcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWF0Y2ggdGhlIG9wZW5pbmcgdGFnLlxuICAgIGlmICghc2Nhbm5lci5zY2FuKG9wZW5pbmdUYWdSZSkpXG4gICAgICBicmVhaztcblxuICAgIGhhc1RhZyA9IHRydWU7XG5cbiAgICAvLyBHZXQgdGhlIHRhZyB0eXBlLlxuICAgIHR5cGUgPSBzY2FubmVyLnNjYW4odGFnUmUpIHx8ICduYW1lJztcbiAgICBzY2FubmVyLnNjYW4od2hpdGVSZSk7XG5cbiAgICAvLyBHZXQgdGhlIHRhZyB2YWx1ZS5cbiAgICBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGVxdWFsc1JlKTtcbiAgICAgIHNjYW5uZXIuc2NhbihlcXVhbHNSZSk7XG4gICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3snKSB7XG4gICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdDdXJseVJlKTtcbiAgICAgIHNjYW5uZXIuc2NhbihjdXJseVJlKTtcbiAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB0eXBlID0gJyYnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgfVxuXG4gICAgLy8gTWF0Y2ggdGhlIGNsb3NpbmcgdGFnLlxuICAgIGlmICghc2Nhbm5lci5zY2FuKGNsb3NpbmdUYWdSZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHRhZyBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgaWYgKHR5cGUgPT0gJz4nKSB7XG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcywgaW5kZW50YXRpb24sIHRhZ0luZGV4LCBsaW5lSGFzTm9uU3BhY2UgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW4gPSBbIHR5cGUsIHZhbHVlLCBzdGFydCwgc2Nhbm5lci5wb3MgXTtcbiAgICB9XG4gICAgdGFnSW5kZXgrKztcbiAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICBpZiAodHlwZSA9PT0gJyMnIHx8IHR5cGUgPT09ICdeJykge1xuICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnLycpIHtcbiAgICAgIC8vIENoZWNrIHNlY3Rpb24gbmVzdGluZy5cbiAgICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICAgIGlmICghb3BlblNlY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5vcGVuZWQgc2VjdGlvbiBcIicgKyB2YWx1ZSArICdcIiBhdCAnICsgc3RhcnQpO1xuXG4gICAgICBpZiAob3BlblNlY3Rpb25bMV0gIT09IHZhbHVlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHN0YXJ0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICduYW1lJyB8fCB0eXBlID09PSAneycgfHwgdHlwZSA9PT0gJyYnKSB7XG4gICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgIC8vIFNldCB0aGUgdGFncyBmb3IgdGhlIG5leHQgdGltZSBhcm91bmQuXG4gICAgICBjb21waWxlVGFncyh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc3RyaXBTcGFjZSgpO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gb3BlbiBzZWN0aW9ucyB3aGVuIHdlJ3JlIGRvbmUuXG4gIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgaWYgKG9wZW5TZWN0aW9uKVxuICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gIHJldHVybiBuZXN0VG9rZW5zKHNxdWFzaFRva2Vucyh0b2tlbnMpKTtcbn1cblxuLyoqXG4gKiBDb21iaW5lcyB0aGUgdmFsdWVzIG9mIGNvbnNlY3V0aXZlIHRleHQgdG9rZW5zIGluIHRoZSBnaXZlbiBgdG9rZW5zYCBhcnJheVxuICogdG8gYSBzaW5nbGUgdG9rZW4uXG4gKi9cbmZ1bmN0aW9uIHNxdWFzaFRva2VucyAodG9rZW5zKSB7XG4gIHZhciBzcXVhc2hlZFRva2VucyA9IFtdO1xuXG4gIHZhciB0b2tlbiwgbGFzdFRva2VuO1xuICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGlmICh0b2tlblswXSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbiAmJiBsYXN0VG9rZW5bMF0gPT09ICd0ZXh0Jykge1xuICAgICAgICBsYXN0VG9rZW5bMV0gKz0gdG9rZW5bMV07XG4gICAgICAgIGxhc3RUb2tlblszXSA9IHRva2VuWzNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3F1YXNoZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2VuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzcXVhc2hlZFRva2Vucztcbn1cblxuLyoqXG4gKiBGb3JtcyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgaW50byBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZSB3aGVyZVxuICogdG9rZW5zIHRoYXQgcmVwcmVzZW50IGEgc2VjdGlvbiBoYXZlIHR3byBhZGRpdGlvbmFsIGl0ZW1zOiAxKSBhbiBhcnJheSBvZlxuICogYWxsIHRva2VucyB0aGF0IGFwcGVhciBpbiB0aGF0IHNlY3Rpb24gYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWxcbiAqIHRlbXBsYXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoYXQgc2VjdGlvbi5cbiAqL1xuZnVuY3Rpb24gbmVzdFRva2VucyAodG9rZW5zKSB7XG4gIHZhciBuZXN0ZWRUb2tlbnMgPSBbXTtcbiAgdmFyIGNvbGxlY3RvciA9IG5lc3RlZFRva2VucztcbiAgdmFyIHNlY3Rpb25zID0gW107XG5cbiAgdmFyIHRva2VuLCBzZWN0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICBjYXNlICcjJzpcbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgICBjb2xsZWN0b3IgPSB0b2tlbls0XSA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG4gICAgICAgIHNlY3Rpb25bNV0gPSB0b2tlblsyXTtcbiAgICAgICAgY29sbGVjdG9yID0gc2VjdGlvbnMubGVuZ3RoID4gMCA/IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdWzRdIDogbmVzdGVkVG9rZW5zO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVzdGVkVG9rZW5zO1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIHN0cmluZyBzY2FubmVyIHRoYXQgaXMgdXNlZCBieSB0aGUgdGVtcGxhdGUgcGFyc2VyIHRvIGZpbmRcbiAqIHRva2VucyBpbiB0ZW1wbGF0ZSBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBTY2FubmVyIChzdHJpbmcpIHtcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gIHRoaXMudGFpbCA9IHN0cmluZztcbiAgdGhpcy5wb3MgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB0YWlsIGlzIGVtcHR5IChlbmQgb2Ygc3RyaW5nKS5cbiAqL1xuU2Nhbm5lci5wcm90b3R5cGUuZW9zID0gZnVuY3Rpb24gZW9zICgpIHtcbiAgcmV0dXJuIHRoaXMudGFpbCA9PT0gJyc7XG59O1xuXG4vKipcbiAqIFRyaWVzIHRvIG1hdGNoIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gKiBSZXR1cm5zIHRoZSBtYXRjaGVkIHRleHQgaWYgaXQgY2FuIG1hdGNoLCB0aGUgZW1wdHkgc3RyaW5nIG90aGVyd2lzZS5cbiAqL1xuU2Nhbm5lci5wcm90b3R5cGUuc2NhbiA9IGZ1bmN0aW9uIHNjYW4gKHJlKSB7XG4gIHZhciBtYXRjaCA9IHRoaXMudGFpbC5tYXRjaChyZSk7XG5cbiAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCAhPT0gMClcbiAgICByZXR1cm4gJyc7XG5cbiAgdmFyIHN0cmluZyA9IG1hdGNoWzBdO1xuXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCk7XG4gIHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbi8qKlxuICogU2tpcHMgYWxsIHRleHQgdW50aWwgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBjYW4gYmUgbWF0Y2hlZC4gUmV0dXJuc1xuICogdGhlIHNraXBwZWQgc3RyaW5nLCB3aGljaCBpcyB0aGUgZW50aXJlIHRhaWwgaWYgbm8gbWF0Y2ggY2FuIGJlIG1hZGUuXG4gKi9cblNjYW5uZXIucHJvdG90eXBlLnNjYW5VbnRpbCA9IGZ1bmN0aW9uIHNjYW5VbnRpbCAocmUpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy50YWlsLnNlYXJjaChyZSksIG1hdGNoO1xuXG4gIHN3aXRjaCAoaW5kZXgpIHtcbiAgICBjYXNlIC0xOlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWw7XG4gICAgICB0aGlzLnRhaWwgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMDpcbiAgICAgIG1hdGNoID0gJyc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoaW5kZXgpO1xuICB9XG5cbiAgdGhpcy5wb3MgKz0gbWF0Y2gubGVuZ3RoO1xuXG4gIHJldHVybiBtYXRjaDtcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlbmRlcmluZyBjb250ZXh0IGJ5IHdyYXBwaW5nIGEgdmlldyBvYmplY3QgYW5kXG4gKiBtYWludGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQgKHZpZXcsIHBhcmVudENvbnRleHQpIHtcbiAgdGhpcy52aWV3ID0gdmlldztcbiAgdGhpcy5jYWNoZSA9IHsgJy4nOiB0aGlzLnZpZXcgfTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICogYXMgdGhlIHBhcmVudC5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKHZpZXcpIHtcbiAgcmV0dXJuIG5ldyBDb250ZXh0KHZpZXcsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGlzIGNvbnRleHQsIHRyYXZlcnNpbmdcbiAqIHVwIHRoZSBjb250ZXh0IGhpZXJhcmNoeSBpZiB0aGUgdmFsdWUgaXMgYWJzZW50IGluIHRoaXMgY29udGV4dCdzIHZpZXcuXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cCAobmFtZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG4gIHZhciB2YWx1ZTtcbiAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgdmFsdWUgPSBjYWNoZVtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsIGludGVybWVkaWF0ZVZhbHVlLCBuYW1lcywgaW5kZXgsIGxvb2t1cEhpdCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgICAgaW50ZXJtZWRpYXRlVmFsdWUgPSBjb250ZXh0LnZpZXc7XG4gICAgICAgIG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzaW5nIHRoZSBkb3Qgbm90aW9uIHBhdGggaW4gYG5hbWVgLCB3ZSBkZXNjZW5kIHRocm91Z2ggdGhlXG4gICAgICAgICAqIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBiZSBjZXJ0YWluIHRoYXQgdGhlIGxvb2t1cCBoYXMgYmVlbiBzdWNjZXNzZnVsLCB3ZSBoYXZlIHRvXG4gICAgICAgICAqIGNoZWNrIGlmIHRoZSBsYXN0IG9iamVjdCBpbiB0aGUgcGF0aCBhY3R1YWxseSBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAqIHdlIGFyZSBsb29raW5nIGZvci4gV2Ugc3RvcmUgdGhlIHJlc3VsdCBpbiBgbG9va3VwSGl0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBzcGVjaWFsbHkgbmVjZXNzYXJ5IGZvciB3aGVuIHRoZSB2YWx1ZSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgICAgICogYHVuZGVmaW5lZGAgYW5kIHdlIHdhbnQgdG8gYXZvaWQgbG9va2luZyB1cCBwYXJlbnQgY29udGV4dHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIGRvdCBub3RhdGlvbiBpcyB1c2VkLCB3ZSBjb25zaWRlciB0aGUgbG9va3VwXG4gICAgICAgICAqIHRvIGJlIHN1Y2Nlc3NmdWwgZXZlbiBpZiB0aGUgbGFzdCBcIm9iamVjdFwiIGluIHRoZSBwYXRoIGlzXG4gICAgICAgICAqIG5vdCBhY3R1YWxseSBhbiBvYmplY3QgYnV0IGEgcHJpbWl0aXZlIChlLmcuLCBhIHN0cmluZywgb3IgYW5cbiAgICAgICAgICogaW50ZWdlciksIGJlY2F1c2UgaXQgaXMgc29tZXRpbWVzIHVzZWZ1bCB0byBhY2Nlc3MgYSBwcm9wZXJ0eVxuICAgICAgICAgKiBvZiBhbiBhdXRvYm94ZWQgcHJpbWl0aXZlLCBzdWNoIGFzIHRoZSBsZW5ndGggb2YgYSBzdHJpbmcuXG4gICAgICAgICAqKi9cbiAgICAgICAgd2hpbGUgKGludGVybWVkaWF0ZVZhbHVlICE9IG51bGwgJiYgaW5kZXggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IG5hbWVzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICBsb29rdXBIaXQgPSAoXG4gICAgICAgICAgICAgIGhhc1Byb3BlcnR5KGludGVybWVkaWF0ZVZhbHVlLCBuYW1lc1tpbmRleF0pXG4gICAgICAgICAgICAgIHx8IHByaW1pdGl2ZUhhc093blByb3BlcnR5KGludGVybWVkaWF0ZVZhbHVlLCBuYW1lc1tpbmRleF0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgaW50ZXJtZWRpYXRlVmFsdWUgPSBpbnRlcm1lZGlhdGVWYWx1ZVtuYW1lc1tpbmRleCsrXV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybWVkaWF0ZVZhbHVlID0gY29udGV4dC52aWV3W25hbWVdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGNoZWNraW5nIGFnYWluc3QgYGhhc1Byb3BlcnR5YCwgd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYCBpZlxuICAgICAgICAgKiBgY29udGV4dC52aWV3YCBpcyBub3QgYW4gb2JqZWN0LiBEZWxpYmVyYXRlbHkgb21pdHRpbmcgdGhlIGNoZWNrXG4gICAgICAgICAqIGFnYWluc3QgYHByaW1pdGl2ZUhhc093blByb3BlcnR5YCBpZiBkb3Qgbm90YXRpb24gaXMgbm90IHVzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnNpZGVyIHRoaXMgZXhhbXBsZTpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIE11c3RhY2hlLnJlbmRlcihcIlRoZSBsZW5ndGggb2YgYSBmb290YmFsbCBmaWVsZCBpcyB7eyNsZW5ndGh9fXt7bGVuZ3RofX17ey9sZW5ndGh9fS5cIiwge2xlbmd0aDogXCIxMDAgeWFyZHNcIn0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB3ZSB3ZXJlIHRvIGNoZWNrIGFsc28gYWdhaW5zdCBgcHJpbWl0aXZlSGFzT3duUHJvcGVydHlgLCBhcyB3ZSBkb1xuICAgICAgICAgKiBpbiB0aGUgZG90IG5vdGF0aW9uIGNhc2UsIHRoZW4gcmVuZGVyIGNhbGwgd291bGQgcmV0dXJuOlxuICAgICAgICAgKlxuICAgICAgICAgKiBcIlRoZSBsZW5ndGggb2YgYSBmb290YmFsbCBmaWVsZCBpcyA5LlwiXG4gICAgICAgICAqXG4gICAgICAgICAqIHJhdGhlciB0aGFuIHRoZSBleHBlY3RlZDpcbiAgICAgICAgICpcbiAgICAgICAgICogXCJUaGUgbGVuZ3RoIG9mIGEgZm9vdGJhbGwgZmllbGQgaXMgMTAwIHlhcmRzLlwiXG4gICAgICAgICAqKi9cbiAgICAgICAgbG9va3VwSGl0ID0gaGFzUHJvcGVydHkoY29udGV4dC52aWV3LCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvb2t1cEhpdCkge1xuICAgICAgICB2YWx1ZSA9IGludGVybWVkaWF0ZVZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgIH1cblxuICAgIGNhY2hlW25hbWVdID0gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgdmFsdWUgPSB2YWx1ZS5jYWxsKHRoaXMudmlldyk7XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBBIFdyaXRlciBrbm93cyBob3cgdG8gdGFrZSBhIHN0cmVhbSBvZiB0b2tlbnMgYW5kIHJlbmRlciB0aGVtIHRvIGFcbiAqIHN0cmluZywgZ2l2ZW4gYSBjb250ZXh0LiBJdCBhbHNvIG1haW50YWlucyBhIGNhY2hlIG9mIHRlbXBsYXRlcyB0b1xuICogYXZvaWQgdGhlIG5lZWQgdG8gcGFyc2UgdGhlIHNhbWUgdGVtcGxhdGUgdHdpY2UuXG4gKi9cbmZ1bmN0aW9uIFdyaXRlciAoKSB7XG4gIHRoaXMudGVtcGxhdGVDYWNoZSA9IHtcbiAgICBfY2FjaGU6IHt9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0IChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl9jYWNoZVtrZXldID0gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVba2V5XTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhpcyB3cml0ZXIuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICBpZiAodHlwZW9mIHRoaXMudGVtcGxhdGVDYWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGB0YWdzYCBvclxuICogYG11c3RhY2hlLnRhZ3NgIGlmIGB0YWdzYCBpcyBvbWl0dGVkLCAgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHRva2Vuc1xuICogdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcGFyc2UuXG4gKi9cbldyaXRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy50ZW1wbGF0ZUNhY2hlO1xuICB2YXIgY2FjaGVLZXkgPSB0ZW1wbGF0ZSArICc6JyArICh0YWdzIHx8IG11c3RhY2hlLnRhZ3MpLmpvaW4oJzonKTtcbiAgdmFyIGlzQ2FjaGVFbmFibGVkID0gdHlwZW9mIGNhY2hlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIHRva2VucyA9IGlzQ2FjaGVFbmFibGVkID8gY2FjaGUuZ2V0KGNhY2hlS2V5KSA6IHVuZGVmaW5lZDtcblxuICBpZiAodG9rZW5zID09IHVuZGVmaW5lZCkge1xuICAgIHRva2VucyA9IHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHRhZ3MpO1xuICAgIGlzQ2FjaGVFbmFibGVkICYmIGNhY2hlLnNldChjYWNoZUtleSwgdG9rZW5zKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuLyoqXG4gKiBIaWdoLWxldmVsIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHdpdGhcbiAqIHRoZSBnaXZlbiBgdmlld2AuXG4gKlxuICogVGhlIG9wdGlvbmFsIGBwYXJ0aWFsc2AgYXJndW1lbnQgbWF5IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICogbmFtZXMgYW5kIHRlbXBsYXRlcyBvZiBwYXJ0aWFscyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0ZW1wbGF0ZS4gSXQgbWF5XG4gKiBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGxvYWQgcGFydGlhbCB0ZW1wbGF0ZXMgb24gdGhlIGZseVxuICogdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlIG5hbWUgb2YgdGhlIHBhcnRpYWwuXG4gKlxuICogSWYgdGhlIG9wdGlvbmFsIGBjb25maWdgIGFyZ3VtZW50IGlzIGdpdmVuIGhlcmUsIHRoZW4gaXQgc2hvdWxkIGJlIGFuXG4gKiBvYmplY3Qgd2l0aCBhIGB0YWdzYCBhdHRyaWJ1dGUgb3IgYW4gYGVzY2FwZWAgYXR0cmlidXRlIG9yIGJvdGguXG4gKiBJZiBhbiBhcnJheSBpcyBwYXNzZWQsIHRoZW4gaXQgd2lsbCBiZSBpbnRlcnByZXRlZCB0aGUgc2FtZSB3YXkgYXNcbiAqIGEgYHRhZ3NgIGF0dHJpYnV0ZSBvbiBhIGBjb25maWdgIG9iamVjdC5cbiAqXG4gKiBUaGUgYHRhZ3NgIGF0dHJpYnV0ZSBvZiBhIGBjb25maWdgIG9iamVjdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvXG4gKiBzdHJpbmcgdmFsdWVzOiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIChlLmcuXG4gKiBbIFwiPCVcIiwgXCIlPlwiIF0pLiBUaGUgZGVmYXVsdCBpcyB0byBtdXN0YWNoZS50YWdzLlxuICpcbiAqIFRoZSBgZXNjYXBlYCBhdHRyaWJ1dGUgb2YgYSBgY29uZmlnYCBvYmplY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIHdoaWNoXG4gKiBhY2NlcHRzIGEgc3RyaW5nIGFzIGlucHV0IGFuZCBvdXRwdXRzIGEgc2FmZWx5IGVzY2FwZWQgc3RyaW5nLlxuICogSWYgYW4gYGVzY2FwZWAgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuIGFuIEhUTUwtc2FmZSBzdHJpbmdcbiAqIGVzY2FwaW5nIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGRlZmF1bHQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIGNvbmZpZykge1xuICB2YXIgdGFncyA9IHRoaXMuZ2V0Q29uZmlnVGFncyhjb25maWcpO1xuICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gIHZhciBjb250ZXh0ID0gKHZpZXcgaW5zdGFuY2VvZiBDb250ZXh0KSA/IHZpZXcgOiBuZXcgQ29udGV4dCh2aWV3LCB1bmRlZmluZWQpO1xuICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgdGVtcGxhdGUsIGNvbmZpZyk7XG59O1xuXG4vKipcbiAqIExvdy1sZXZlbCBtZXRob2QgdGhhdCByZW5kZXJzIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCB1c2luZ1xuICogdGhlIGdpdmVuIGBjb250ZXh0YCBhbmQgYHBhcnRpYWxzYC5cbiAqXG4gKiBOb3RlOiBUaGUgYG9yaWdpbmFsVGVtcGxhdGVgIGlzIG9ubHkgZXZlciB1c2VkIHRvIGV4dHJhY3QgdGhlIHBvcnRpb25cbiAqIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHdhcyBjb250YWluZWQgaW4gYSBoaWdoZXItb3JkZXIgc2VjdGlvbi5cbiAqIElmIHRoZSB0ZW1wbGF0ZSBkb2Vzbid0IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMsIHRoaXMgYXJndW1lbnQgbWF5XG4gKiBiZSBvbWl0dGVkLlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlclRva2VucyA9IGZ1bmN0aW9uIHJlbmRlclRva2VucyAodG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKSB7XG4gIHZhciBidWZmZXIgPSAnJztcblxuICB2YXIgdG9rZW4sIHN5bWJvbCwgdmFsdWU7XG4gIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBzeW1ib2wgPSB0b2tlblswXTtcblxuICAgIGlmIChzeW1ib2wgPT09ICcjJykgdmFsdWUgPSB0aGlzLnJlbmRlclNlY3Rpb24odG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ14nKSB2YWx1ZSA9IHRoaXMucmVuZGVySW52ZXJ0ZWQodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJz4nKSB2YWx1ZSA9IHRoaXMucmVuZGVyUGFydGlhbCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAnJicpIHZhbHVlID0gdGhpcy51bmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAnbmFtZScpIHZhbHVlID0gdGhpcy5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAndGV4dCcpIHZhbHVlID0gdGhpcy5yYXdWYWx1ZSh0b2tlbik7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiByZW5kZXJTZWN0aW9uICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBidWZmZXIgPSAnJztcbiAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZW5kZXIgYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gIC8vIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYnkgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLlxuICBmdW5jdGlvbiBzdWJSZW5kZXIgKHRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscywgY29uZmlnKTtcbiAgfVxuXG4gIGlmICghdmFsdWUpIHJldHVybjtcblxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGogPCB2YWx1ZUxlbmd0aDsgKytqKSB7XG4gICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZVtqXSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsVGVtcGxhdGUgIT09ICdzdHJpbmcnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucyB3aXRob3V0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZScpO1xuXG4gICAgLy8gRXh0cmFjdCB0aGUgcG9ydGlvbiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB0aGUgc2VjdGlvbiBjb250YWlucy5cbiAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoY29udGV4dC52aWV3LCBvcmlnaW5hbFRlbXBsYXRlLnNsaWNlKHRva2VuWzNdLCB0b2tlbls1XSksIHN1YlJlbmRlcik7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlckludmVydGVkID0gZnVuY3Rpb24gcmVuZGVySW52ZXJ0ZWQgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAvLyBVc2UgSmF2YVNjcmlwdCdzIGRlZmluaXRpb24gb2YgZmFsc3kuIEluY2x1ZGUgZW1wdHkgYXJyYXlzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4NlxuICBpZiAoIXZhbHVlIHx8IChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKVxuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLmluZGVudFBhcnRpYWwgPSBmdW5jdGlvbiBpbmRlbnRQYXJ0aWFsIChwYXJ0aWFsLCBpbmRlbnRhdGlvbiwgbGluZUhhc05vblNwYWNlKSB7XG4gIHZhciBmaWx0ZXJlZEluZGVudGF0aW9uID0gaW5kZW50YXRpb24ucmVwbGFjZSgvW14gXFx0XS9nLCAnJyk7XG4gIHZhciBwYXJ0aWFsQnlObCA9IHBhcnRpYWwuc3BsaXQoJ1xcbicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpYWxCeU5sLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnRpYWxCeU5sW2ldLmxlbmd0aCAmJiAoaSA+IDAgfHwgIWxpbmVIYXNOb25TcGFjZSkpIHtcbiAgICAgIHBhcnRpYWxCeU5sW2ldID0gZmlsdGVyZWRJbmRlbnRhdGlvbiArIHBhcnRpYWxCeU5sW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydGlhbEJ5Tmwuam9pbignXFxuJyk7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlclBhcnRpYWwgPSBmdW5jdGlvbiByZW5kZXJQYXJ0aWFsICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIGNvbmZpZykge1xuICBpZiAoIXBhcnRpYWxzKSByZXR1cm47XG4gIHZhciB0YWdzID0gdGhpcy5nZXRDb25maWdUYWdzKGNvbmZpZyk7XG5cbiAgdmFyIHZhbHVlID0gaXNGdW5jdGlvbihwYXJ0aWFscykgPyBwYXJ0aWFscyh0b2tlblsxXSkgOiBwYXJ0aWFsc1t0b2tlblsxXV07XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdmFyIGxpbmVIYXNOb25TcGFjZSA9IHRva2VuWzZdO1xuICAgIHZhciB0YWdJbmRleCA9IHRva2VuWzVdO1xuICAgIHZhciBpbmRlbnRhdGlvbiA9IHRva2VuWzRdO1xuICAgIHZhciBpbmRlbnRlZFZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHRhZ0luZGV4ID09IDAgJiYgaW5kZW50YXRpb24pIHtcbiAgICAgIGluZGVudGVkVmFsdWUgPSB0aGlzLmluZGVudFBhcnRpYWwodmFsdWUsIGluZGVudGF0aW9uLCBsaW5lSGFzTm9uU3BhY2UpO1xuICAgIH1cbiAgICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZShpbmRlbnRlZFZhbHVlLCB0YWdzKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50ZWRWYWx1ZSwgY29uZmlnKTtcbiAgfVxufTtcblxuV3JpdGVyLnByb3RvdHlwZS51bmVzY2FwZWRWYWx1ZSA9IGZ1bmN0aW9uIHVuZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCkge1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCwgY29uZmlnKSB7XG4gIHZhciBlc2NhcGUgPSB0aGlzLmdldENvbmZpZ0VzY2FwZShjb25maWcpIHx8IG11c3RhY2hlLmVzY2FwZTtcbiAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgZXNjYXBlID09PSBtdXN0YWNoZS5lc2NhcGUpID8gU3RyaW5nKHZhbHVlKSA6IGVzY2FwZSh2YWx1ZSk7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnJhd1ZhbHVlID0gZnVuY3Rpb24gcmF3VmFsdWUgKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblsxXTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUuZ2V0Q29uZmlnVGFncyA9IGZ1bmN0aW9uIGdldENvbmZpZ1RhZ3MgKGNvbmZpZykge1xuICBpZiAoaXNBcnJheShjb25maWcpKSB7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBlbHNlIGlmIChjb25maWcgJiYgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gY29uZmlnLnRhZ3M7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuV3JpdGVyLnByb3RvdHlwZS5nZXRDb25maWdFc2NhcGUgPSBmdW5jdGlvbiBnZXRDb25maWdFc2NhcGUgKGNvbmZpZykge1xuICBpZiAoY29uZmlnICYmIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmICFpc0FycmF5KGNvbmZpZykpIHtcbiAgICByZXR1cm4gY29uZmlnLmVzY2FwZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG52YXIgbXVzdGFjaGUgPSB7XG4gIG5hbWU6ICdtdXN0YWNoZS5qcycsXG4gIHZlcnNpb246ICc0LjIuMCcsXG4gIHRhZ3M6IFsgJ3t7JywgJ319JyBdLFxuICBjbGVhckNhY2hlOiB1bmRlZmluZWQsXG4gIGVzY2FwZTogdW5kZWZpbmVkLFxuICBwYXJzZTogdW5kZWZpbmVkLFxuICByZW5kZXI6IHVuZGVmaW5lZCxcbiAgU2Nhbm5lcjogdW5kZWZpbmVkLFxuICBDb250ZXh0OiB1bmRlZmluZWQsXG4gIFdyaXRlcjogdW5kZWZpbmVkLFxuICAvKipcbiAgICogQWxsb3dzIGEgdXNlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBjYWNoaW5nIHN0cmF0ZWd5LCBieSBwcm92aWRpbmcgYW5cbiAgICogb2JqZWN0IHdpdGggc2V0LCBnZXQgYW5kIGNsZWFyIG1ldGhvZHMuIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBkaXNhYmxlXG4gICAqIHRoZSBjYWNoZSBieSBzZXR0aW5nIGl0IHRvIHRoZSBsaXRlcmFsIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgc2V0IHRlbXBsYXRlQ2FjaGUgKGNhY2hlKSB7XG4gICAgZGVmYXVsdFdyaXRlci50ZW1wbGF0ZUNhY2hlID0gY2FjaGU7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkZWZhdWx0IG9yIG92ZXJyaWRkZW4gY2FjaGluZyBvYmplY3QgZnJvbSB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBnZXQgdGVtcGxhdGVDYWNoZSAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIudGVtcGxhdGVDYWNoZTtcbiAgfVxufTtcblxuLy8gQWxsIGhpZ2gtbGV2ZWwgbXVzdGFjaGUuKiBmdW5jdGlvbnMgdXNlIHRoaXMgd3JpdGVyLlxudmFyIGRlZmF1bHRXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG5cbi8qKlxuICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAqL1xubXVzdGFjaGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICByZXR1cm4gZGVmYXVsdFdyaXRlci5jbGVhckNhY2hlKCk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiB0ZW1wbGF0ZSBpbiB0aGUgZGVmYXVsdCB3cml0ZXIgYW5kIHJldHVybnMgdGhlXG4gKiBhcnJheSBvZiB0b2tlbnMgaXQgY29udGFpbnMuIERvaW5nIHRoaXMgYWhlYWQgb2YgdGltZSBhdm9pZHMgdGhlIG5lZWQgdG9cbiAqIHBhcnNlIHRlbXBsYXRlcyBvbiB0aGUgZmx5IGFzIHRoZXkgYXJlIHJlbmRlcmVkLlxuICovXG5tdXN0YWNoZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICh0ZW1wbGF0ZSwgdGFncykge1xuICByZXR1cm4gZGVmYXVsdFdyaXRlci5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGB0ZW1wbGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHZpZXdgLCBgcGFydGlhbHNgLCBhbmQgYGNvbmZpZ2BcbiAqIHVzaW5nIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAqL1xubXVzdGFjaGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIGNvbmZpZykge1xuICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUhIFRlbXBsYXRlIHNob3VsZCBiZSBhIFwic3RyaW5nXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV0IFwiJyArIHR5cGVTdHIodGVtcGxhdGUpICsgJ1wiIHdhcyBnaXZlbiBhcyB0aGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnQgZm9yIG11c3RhY2hlI3JlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpJyk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFdyaXRlci5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBjb25maWcpO1xufTtcblxuLy8gRXhwb3J0IHRoZSBlc2NhcGluZyBmdW5jdGlvbiBzbyB0aGF0IHRoZSB1c2VyIG1heSBvdmVycmlkZSBpdC5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMjQ0XG5tdXN0YWNoZS5lc2NhcGUgPSBlc2NhcGVIdG1sO1xuXG4vLyBFeHBvcnQgdGhlc2UgbWFpbmx5IGZvciB0ZXN0aW5nLCBidXQgYWxzbyBmb3IgYWR2YW5jZWQgdXNhZ2UuXG5tdXN0YWNoZS5TY2FubmVyID0gU2Nhbm5lcjtcbm11c3RhY2hlLkNvbnRleHQgPSBDb250ZXh0O1xubXVzdGFjaGUuV3JpdGVyID0gV3JpdGVyO1xuXG5leHBvcnQgZGVmYXVsdCBtdXN0YWNoZTtcbiJdLCJuYW1lcyI6WyJvYmplY3RUb1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaXNBcnJheSIsIkFycmF5IiwiaXNBcnJheVBvbHlmaWxsIiwib2JqZWN0IiwiY2FsbCIsImlzRnVuY3Rpb24iLCJ0eXBlU3RyIiwib2JqIiwiZXNjYXBlUmVnRXhwIiwic3RyaW5nIiwicmVwbGFjZSIsImhhc1Byb3BlcnR5IiwicHJvcE5hbWUiLCJwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eSIsInByaW1pdGl2ZSIsImhhc093blByb3BlcnR5IiwicmVnRXhwVGVzdCIsIlJlZ0V4cCIsInRlc3QiLCJ0ZXN0UmVnRXhwIiwicmUiLCJub25TcGFjZVJlIiwiaXNXaGl0ZXNwYWNlIiwiZW50aXR5TWFwIiwiZXNjYXBlSHRtbCIsIlN0cmluZyIsImZyb21FbnRpdHlNYXAiLCJzIiwid2hpdGVSZSIsInNwYWNlUmUiLCJlcXVhbHNSZSIsImN1cmx5UmUiLCJ0YWdSZSIsInBhcnNlVGVtcGxhdGUiLCJ0ZW1wbGF0ZSIsInRhZ3MiLCJsaW5lSGFzTm9uU3BhY2UiLCJzZWN0aW9ucyIsInRva2VucyIsInNwYWNlcyIsImhhc1RhZyIsIm5vblNwYWNlIiwiaW5kZW50YXRpb24iLCJ0YWdJbmRleCIsInN0cmlwU3BhY2UiLCJsZW5ndGgiLCJwb3AiLCJvcGVuaW5nVGFnUmUiLCJjbG9zaW5nVGFnUmUiLCJjbG9zaW5nQ3VybHlSZSIsImNvbXBpbGVUYWdzIiwidGFnc1RvQ29tcGlsZSIsInNwbGl0IiwiRXJyb3IiLCJtdXN0YWNoZSIsInNjYW5uZXIiLCJTY2FubmVyIiwic3RhcnQiLCJ0eXBlIiwidmFsdWUiLCJjaHIiLCJ0b2tlbiIsIm9wZW5TZWN0aW9uIiwiZW9zIiwicG9zIiwic2NhblVudGlsIiwiaSIsInZhbHVlTGVuZ3RoIiwiY2hhckF0IiwicHVzaCIsInNjYW4iLCJuZXN0VG9rZW5zIiwic3F1YXNoVG9rZW5zIiwic3F1YXNoZWRUb2tlbnMiLCJsYXN0VG9rZW4iLCJudW1Ub2tlbnMiLCJuZXN0ZWRUb2tlbnMiLCJjb2xsZWN0b3IiLCJzZWN0aW9uIiwidGFpbCIsIm1hdGNoIiwiaW5kZXgiLCJzdWJzdHJpbmciLCJzZWFyY2giLCJDb250ZXh0IiwidmlldyIsInBhcmVudENvbnRleHQiLCJjYWNoZSIsInBhcmVudCIsImxvb2t1cCIsIm5hbWUiLCJjb250ZXh0IiwiaW50ZXJtZWRpYXRlVmFsdWUiLCJuYW1lcyIsImxvb2t1cEhpdCIsImluZGV4T2YiLCJXcml0ZXIiLCJ0ZW1wbGF0ZUNhY2hlIiwiX2NhY2hlIiwic2V0Iiwia2V5IiwiZ2V0IiwiY2xlYXIiLCJjbGVhckNhY2hlIiwicGFyc2UiLCJjYWNoZUtleSIsImpvaW4iLCJpc0NhY2hlRW5hYmxlZCIsInVuZGVmaW5lZCIsInJlbmRlciIsInBhcnRpYWxzIiwiY29uZmlnIiwiZ2V0Q29uZmlnVGFncyIsInJlbmRlclRva2VucyIsIm9yaWdpbmFsVGVtcGxhdGUiLCJidWZmZXIiLCJzeW1ib2wiLCJyZW5kZXJTZWN0aW9uIiwicmVuZGVySW52ZXJ0ZWQiLCJyZW5kZXJQYXJ0aWFsIiwidW5lc2NhcGVkVmFsdWUiLCJlc2NhcGVkVmFsdWUiLCJyYXdWYWx1ZSIsInNlbGYiLCJzdWJSZW5kZXIiLCJqIiwic2xpY2UiLCJpbmRlbnRQYXJ0aWFsIiwicGFydGlhbCIsImZpbHRlcmVkSW5kZW50YXRpb24iLCJwYXJ0aWFsQnlObCIsImluZGVudGVkVmFsdWUiLCJlc2NhcGUiLCJnZXRDb25maWdFc2NhcGUiLCJ2ZXJzaW9uIiwiZGVmYXVsdFdyaXRlciIsIlR5cGVFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mustache/mustache.mjs\n");

/***/ })

};
;